%!TEX root = ACC2019.tex

\begin{section}{Approach}
\label{sec:approach}
In this section we describe the framework for detection of sensor attacks for systems with unknown or changing dynamics and adaptive motion planning to solve Problems \ref{problem1} and \ref{problem2} and ensure vehicle's safety. We follow the architecture in the block diagram of Fig. \ref{fig:system_arch} to solve these problems. A detector monitors sensor measurements and calculates inputs for sensor attacks, which allows an uncompromised input $u(k)$ to control the system. At the same time, the state estimator along with the high level motion planner update the reference $r(k)$ of the controller to ensure safety. Next, we describe the framework for attack detection and sensor reconfiguration problems using a series of adaptive controlled systems.

\begin{figure}[ht!]
\vspace{1pt}
\centering
\includegraphics[width=0.46\textwidth]{sys_arch.png}
\caption{Overall system architecture showing the relationship between the reference model adaptive controller and the adaptive motion planner.}
\label{fig:system_arch}
\end{figure}

\subsection{Resilient Adaptive Control}
\label{sec:Res_adapt_control}


In order to detect and remove attacks we propose the architecture in Fig. \ref{fig:det_arch} in which redundant sensor measurements are considered. Specifically, multiple subsystems are considered, one for each sensor measurement and within each subsystem a model reference adaptive control scheme is implemented to obtain the desired input $u^*$ to track a reference signal $y^*$. As in our previous work \cite{6943080,6843720} we assume that less than $s/2$ sensors can be compromised in order to estimate the state of the system.


% The architecture followed in this work is shown in Fig. \ref{fig:det_arch}, which consists of a subsystem for each sensor measurement within the same controlled state. Each subsystem consists of a model reference adaptive controller to generate the next input $u^*_i$ where $i=1,2,\dots,s$ given its corresponding measurement signal $y_i$.

\begin{figure}[ht!]
\vspace{1pt}
\centering
\includegraphics[width=0.48\textwidth]{con_and_det.png}
\caption{Architecture of the detection scheme within the adaptive controlled system. Representing  the $s$ number of available measurements, each of their adaptive subsystems generate a temporary input to be sent to the attack detector. From there, the detector removes measurement subsystems that are compromised.}
\label{fig:det_arch}
\end{figure}
%\eqref{eq:Start}$-$\eqref{eq:End}

First, to design the resilient model reference adaptive controller, we assume that:
	\begin{enumerate}[leftmargin=3\parindent]
	\item[$A1)$] all zeros of $B^{'}(z^{-1})z^q$ from \eqref{eq:B_prime} are within $|z|<1$. 
	\item[$A2)$] $p$ and $q$ are known. 
	\item[$A3)$] the system delay $d$ is known.
	\item[$A4)$] all poles of $E(z^{-1})z^w$ from \eqref{eq:reference model_z} are within $|z|<1$.
	\end{enumerate}
The zeros $z$ of the system are within the discrete $z-plane$ while $p$, $q$, and $d$ are the dimensions of \eqref{eq:transfer_function}. With these assumptions satisfied, every $i^{th}$ subsystem can generate an input signal $u^*_i(k)$ to have its measurement signal $y_i$ track a given tracking signal $y^*$ from the reference model \eqref{eq:reference model_z}. Many of the steps to design the Characteristic Model Based all-coefficient Model Reference Adaptive Controller are omitted here, which can be found in \cite{tao2003adaptive,Goodwin1643720}, however we provide the main equations to compute the next input. A parameter vector of unknown coefficients describing the system's transfer function \eqref{eq:transfer_function} to follow the desired reference model is described as:
    \begin{equation}
	\bm{\theta}_0=(\alpha_0, \dots ,\alpha_{p-1},\beta_0, \dots ,\beta_{q+d-1})^T \in \R^{p+q+d}
	\end{equation}
The objective of the adaptive control is to estimate the true parameters of $\bm{\theta}_0$ with the parameter estimate vector $\bm{\theta}^T(k)$:\NB{no need to put the transpose in $\bm{\theta}^T(k)$}
    \begin{equation}
    \bm{\theta}(k)=(\theta_1(k), \dots ,\theta_p(k),\theta_{p+1}(k), \dots ,\theta_{p+q+d}(k))^T
	\end{equation}
With our known input and measurement signals within a signal vector $\bm{\phi}(k)$,
    
	\begin{align}
	\begin{split}
	\bm{\phi}(k)&=(y_i(k), \dots ,y_i(k-p+1),u^*_i(k), \dots , \\
	& u^*_i(k-q-d+1))^T \in \R^{p+q+d}
	\end{split}
	\end{align}
we can estimate the true parameter vector $\bm{\theta}_0$ by updating the parameter estimate vector $\bm{\theta}^T(k)$ using a \textit{Modified Projection Algorithm} \NB{reference here?}:
	\begin{equation}
	\label{eq:Modified_Proj_Algorithm}
	\bm{\theta}(k)=\bm{\theta}(k-1)+\frac{a(k)\bm{\phi}(k-d)e(k)}{c+\bm{\phi}^T(k-d)\bm{\phi}(k-d)}
	\end{equation}
	\begin{equation}
	e(k)=E(z^{-1})y_i(k)-\theta^T(k-1)\bm{\phi}(k-d)
	\end{equation}
	\begin{align*}
	\epsilon<a(k)<2-\epsilon, 0,\epsilon<1, c>0
	\end{align*}
To follow the desired tracking output $y^*(k)$ from the reference model, the adaptive control input $u^*_i(k)$ is then calculated from the equation:
    \begin{equation}
    \label{eq:tracking_model}
	\bm{\theta}^T(k)\bm{\phi}(k)=E(z^{-1})y^*(k+d)
	\end{equation}
By rearranging \eqref{eq:tracking_model} we isolate $u^*_i(k)$ to calculate our next input signal for each $i^{th}$ subsystem for $i=1,2,\dots,s$:
	\begin{align}
	\label{eq:End}
	u^*_i(k)=\frac{1}{\theta_{p+1}(k)}&(-\theta_1(k)y_i(k)-\theta_2(k)y_i(k-1)  \nonumber \\
    -\dots-\theta_p(k)y_i(k&-p-1)-\theta_{p+2}(k)u^*_i(k-1)  \\
	-\theta_{p+3}(k)u^*_i(k-2)-& \dots - \theta_{p+q+d}(k)u^*_i(k-q-d+1) \nonumber \\
	+g&H(z^{-1})r(k))^T \nonumber
	\end{align}
    \begin{equation}
	\theta_{p+1}(k)\neq0 \nonumber
	\end{equation}

Once these subsystem inputs are computed, under the assumptions in (A1-A4), we leverage the following MRAC properties to detect sensor attacks when the system model is changing or unknown. The following properties are true \cite{tao2003adaptive},\NB{I would say that in \cite{tao2003adaptive} the following properties were found to be true when implementing a MRAC}
	\begin{enumerate}[label=(\roman*),leftmargin=4\parindent]
	\label{assumtions_ensure}
	\item[$T1)$] $y(k)$ and $u(k)$ are bounded 
	\item[$T2)$] $\lim_{k\to\infty}(y(k)-y^*(k))=0$
	\label{Truth2}
	\item[$T3)$] $\sum_{k=0}^\infty(y(k)-y^*(k))^2<\infty$
	\end{enumerate}
where $y(k)$ is the system output and $y^*(k)$ is a tracking signal from the reference model. This ensures the system's output asymptotically converges to the reference model's tracking signal in a finite amount of time. 


The resilient adaptive controller employs the architecture of redundant subsystems where each sensor measurement $y_i$ has its adaptive controller to generate an input $u^*_i$ to follow a desired tracking signal $y^*_i$. Each of the sensor measurements, when uncompromised, have convergence (T2) towards their desired tracking signal from the corresponding reference model,
    \begin{equation}
    \label{multiple_output_tracking}
    \lim_{k\to\infty}(y_i(k)-y^*_i(k))=0
    \end{equation}
for $i=1,2,\dots,s$. This remains true with a changing reference signal $r_i(k)$, changing dynamics, or bounded disturbances. 

% Each MRAC subsystem calculates an input $u^*_i(k)$ that is fed into the detector, which analyses each to check for attacks. 

Since \eqref{multiple_output_tracking} should hold during any operation, the following \NB{the following what?} is also true:
\begin{equation}
    \label{eq:u_to_0}
    \lim_{k\to\infty}(u^*_i(k)-u^*_j(k))=0, \text{ }i\neq j
\end{equation}
\begin{equation}
    i,j = 1,2,\dots,s \nonumber
\end{equation}
where $u^*_i$ and $u^*_j$ refer to inputs calculated from their respected subsystems to track the same signal $y_i^*(k)$. Each input, under ideal \NB{what does it mean ideal? (i.e., considering perfect measurements with no noise)}conditions, should be the same value as all other subsystem inputs controlling their output to track the same tracking signal. For each subsystem to compute the next input $u^*_i(k)$, their \NB{fix grammar here} sensor measurement $y_i$ needs to be uncompromised. As a measurement is corrupted due to a non-zero element from the sensor attack vector, the corresponding subsystem's computed input diverges from the remaining inputs. \NB{connect better this with what comes next, like: Mathematically, to detect attacks, a difference matrix...}



For attack detection, a difference matrix $\bm{\Psi}(k)$ is designed for every time interval $k$ of each controlled state. The structure of this matrix is,
    \begin{equation}
    \label{eq:difference_matrix}
	\bm{\Psi}(k)=\begin{bmatrix} \psi_{1,1}(k) & \psi_{1,2}(k) & \dots & \psi_{1,s}(k) \\ \psi_{2,1}(k) & \psi_{2,2}(k) &  &  \\ \vdots &  & \ddots &  \\ \psi_{s,1}(k) &  &  & \psi_{s,s}(k) \end{bmatrix}
	\end{equation}
where $\bm{\Psi}(k) \in \R^{s\times s}$ with $s$ representing the number of available measurements from the measurement vector $\bm{y} \in \R^s$ \NB{not needed...you have already presented s}. Each element $\psi_{i,j}\in\bm{\Psi}$ is an error computed as the absolute difference between two temporary \NB{remove temporary} subsystem inputs:
    \begin{equation}
        \psi_{i,j}(k)=|u^*_i(k)-u^*_j(k)|
    \end{equation}
The $l_1$ vector norm for each row in the difference matrix \eqref{eq:difference_matrix} is computed which gives us the following difference vector \NB{why difference vector?}:
    \begin{equation}
    \label{eq:difference_vector}
	\bm{\Psi^{'}}(k)=\begin{bmatrix} \lVert{\bm{\Psi}_1(k)}\rVert_1 \\ \lVert{\bm{\Psi}_2(k)}\rVert_1 \\ \vdots \\ \lVert{\bm{\Psi}_s(k)}\rVert_1 \end{bmatrix}
	\end{equation}
The minimum valued element of \eqref{eq:difference_vector} is used to form another vector $\bm{\Psi}^{'}_{min}(k) \in \R^s$, with every element equal to $\min \bm{\Psi}^{'}(k)$:
    \begin{equation}
	\bm{\Psi}^{'}_{min}(k)=\begin{bmatrix} \min \bm{\Psi}^{'}(k),& \dots \text{ },&\min \bm{\Psi}^{'}(k) \end{bmatrix}^T
	\end{equation}
	\NB{maybe you can represent this as $\bm{\Psi}^{'}_{min}(k)=\min \bm{\Psi}^{'}(k) \left[\bf{1}\right]_s$ with $\left[\bf{1}\right]_s$ a column vector of 1s...check I think there is a formal way to represent such vector}
We now define the updated error vector as:
    \begin{align}
    \label{eq:Psi2}
	\bm{\Psi^{''}}(k)&=\bm{\Psi^{'}}(k)-\bm{\Psi}^{'}_{min}(k) \\
	& =\begin{bmatrix} \lVert{\bm{\Psi}_1(k)}\rVert_1 - \min \bm{\Psi}^{'}(k)\\ \lVert{\bm{\Psi}_2(k)}\rVert_1 - \min \bm{\Psi}^{'}(k) \\ \vdots \\ \lVert{\bm{\Psi}_s(k)}\rVert_1 - \min \bm{\Psi}^{'}(k) \end{bmatrix}
	\end{align}
	
From \eqref{eq:u_to_0} while under ideal conditions (i.e., with no noise), the error vector \eqref{eq:Psi2} has all elements equal to zero. When an $i^{th}$ sensor is under attack, the $i^{th}$ input diverges from the remaining uncompromised inputs. The $i^{th}$ element of $\bm{\Psi}^{''}(k)$ becomes non-zero due to the compromised sensor, while the rest of the elements remain zero. 

Under non-ideal conditions where noises exist, the elements of the error vector will not remain zero while sensors are uncompromised. By setting a threshold value $\delta$, all elements of the error vector need to stay below this level. By refining \eqref{eq:Psi2} for non-ideal conditions we get,
    \begin{align}
    \begin{split}
    \label{eq:Psi2_nonideal}
	\bm{\Psi^{''}}(k)&=\bm{\Psi^{'}}(k)-\bm{\Psi}^{'}_{min}(k) \\
	& =\begin{bmatrix} \lVert{\bm{\Psi}_1(k)}\rVert_1 - \min \bm{\Psi}^{'}(k)\\ \lVert{\bm{\Psi}_2(k)}\rVert_1 - \min \bm{\Psi}^{'}(k) \\ \vdots \\ \lVert{\bm{\Psi}_s(k)}\rVert_1 - \min \bm{\Psi}^{'}(k) \end{bmatrix} \leq \bm{\delta}
	\end{split}
	\end{align}
with the vector $\bm{\delta} \in \R^s$ has elements all equal to the scalar value $\delta$, which is computed from the measurement with the highest noise profile \NB{more details needed here. How is $\delta$ computed?}. After detecting and removing the compromised sensors, the updated measurement matrix reduces in size to $\bm{C} \in \R^{s' \times n}$ with $s'=s-s_a$ and the measurement set is $\bm{y}' =\bm{y}\setminus\bm{y}_a$. Once the subsystem inputs $u_i^*(k)$ have been checked by the detector, the uncompromised measurements are fused and then directed to an adaptive controller to compute an input $u(k)$ for the system \NB{block diagram needed here. Modify Fig.2 to show this}.

% DO I NEED THIS?

%Properties of the modified projection algorithm \eqref{eq:Modified_Proj_Algorithm} include:
%    \begin{enumerate}[label=(\roman*),leftmargin=3\parindent]
%	\item every iteration improves estimation:
%	    \begin{align}
%	        \|\bm{\theta}(k)-\bm{\theta}_0\|\leq\|\bm{\theta}(k-1)-\bm{\theta}_0\|, k\geq1 \nonumber
%	    \end{align}
%	\item parameter variation converges to zero:
%	    \begin{align}
%	        \lim_{k\to\infty}(\bm{\theta}(k)-\bm{\theta}(k-N))=0, \text{any finite } N>0 \nonumber
%	    \end{align}
%	\end{enumerate}
	

\subsection{Estimation Confidence}

The vehicle has multiple sensors of various noise profiles that provide state data of the system. Some of these sensors are fused to obtain a better estimation. When a compromised sensor has been removed by the detector, the system uses a smaller set of sensors for state estimation. Thus, we are interested in computing a region of confidence around the state estimate that adapts to the changing sensor set to ensure vehicle safety. We leverage the statistical technique of confidence intervals \cite{devore2011probability} to obtain a specific confidence of an estimate. Confidence intervals are used to calculate bounds which the true mean lies within of a chosen confidence percentage. Assuming the knowledge of the confidence percentage $c_p$, population standard deviation $\sigma$, the number of sensor data samples $N$, and the mean of the $N$ sensor data samples $\bar{x}$, an interval of a percentage of confidence can be calculated:
    \begin{equation}
     \label{Confidence_interval}
		C_x = \bar{x} + c_p\frac{\sigma}{\sqrt{N}}
	\end{equation}
	
% . As the number of data samples increases, the confidence interval shrinks in size to give a better estimation of the true mean \NB{you are giving the results before showing how!}	
	
For state estimation with sensor uncertainties, we need to guarantee the vehicle is within a region \NB{what region?} to prevent navigation into an undesired state \NB{fix this sentence.}. Uncompromised sensor measurements from the set $\bm{y}$ are fused using filtering techniques (e.g. Kalman Filtering) and the result is a position estimate $\hat{\bm{p}}=[\hat{x},\hat{y}]^T$ of a certain variance $\sigma_p^2$, which depends on the known sensor variances from data sheet specifications \NB{no need to add the datasheet}. For our case, a multivariate confidence interval is computed for position estimation, i.e. a confidence region \NB{Not clear. Rephrase}. This method states \NB{how can a method state something???} the vehicle is within the computed region of a specific confidence percentage.


The estimated position data has the form $\mathcal{N}(0,\sigma_p)$ where the data's population standard deviation $\sigma_p$ is known for any sensor combination. Using \eqref{Confidence_interval} we find a multivariate region the vehicle is within of a chosen confidence percentage,
    \begin{equation}
    \label{Confidence_region}
		\hat{\bm{\varepsilon}}_{\hat{\bar{\bm{p}}}|N} = \hat{\bar{\bm{p}}} + c_p\frac{\sigma_p}{\sqrt{N}}
	\end{equation}
with $c_p$ defining the value for a specific confidence percentage, which can be found in $z$-tables and $t$-tables \NB{tables...no need to state z-table because otherwise you need to change the symbol in your expression}in \cite{devore2011probability} and $\hat{\bar{\bm{p}}}$ is the mean position estimate from the $N$ data samples. \NB{This previous expression and explanation needs some work...too many hats and bars in the variables. The text is confusing} The radius of the multivariate confidence region \eqref{Confidence_region} from the center point $\hat{\bar{\bm{p}}}$ is:
    \begin{equation}
    \label{Confidence_radius}
		\hat{\varepsilon} = c_p\frac{\sigma_p}{\sqrt{N}}
	\end{equation}
From \eqref{Confidence_radius}, it is clear \NB{I've notices that you have the tendency to remove "that". Please use it}with a larger number of $N$ data samples, the radius of the confidence region becomes smaller. Similar to the calculation of confidence intervals \eqref{Confidence_interval}, it is under the assumption that the true mean is static (i.e. is not changing over time). This cannot be assumed in the case of position estimation of a navigating vehicle \NB{what's a navigating vehicle? you mean a mobile or moving vehicle}. 

% \begin{figure}[ht!]
% \vspace{1pt}
% \centering
% \includegraphics[width=0.48\textwidth]{Gaussian2D.png}
% \caption{Distribution of vehicle's estimated position over 100 samples in an $X-Y$ plane with equal noise variance on the $X$ and $Y$ axis. Creating a psuedo-static case allows for the calculation of a confidence region for vehicle position.}
% \label{fig:gauss_pdf}
% \end{figure}


\begin{figure}[ht!]
\begin{tabular}{cc}
\subfigure[\label{fig:1sample} ]{\includegraphics[width = 0.22\textwidth]{sample1.png}} &	
\subfigure[\label{fig:5samples} ]{\includegraphics[width = 0.22\textwidth]{sample5.png}}
\end{tabular}
\caption{A comparison of the size of the estimated confidence region as the $N$ number of data samples grow. In \ref{fig:1sample}, the estimated confidence region with 1 data sample is not as accurate. In \ref{fig:5samples}, the $N$ number of samples used is five, which gives a much smaller size and more accurate confidence region.}
\label{fig:confidence_region}
\end{figure}

\NB{To take into account mobility, we propose an adapted approach to compute the confidence interval...} \NB{no past tense!!!}We created a pseudo-static form of a confidence region to compensate for translation of previous estimated position measurements $\hat{\bm{p}}(k-i)$, where $i=1,2,\dots,N-1$. These $N-1$ number of previous measurements need to be represented as if they were all sampled for the current position in time $k$, creating a pseudo-static set of data. As shown in Fig. \ref{fig:confidence_region}, using a pseudo-static \NB{pseudo-static set??? What does it mean? Let's not use these terms unless you have already presented what they are and then given a name}set of measurements, we are able to calculate a confidence region using more than one sample to improve estimation accuracy \NB{what's the purpose of this sentence? Didn't you present before this?}. The $N$ position estimate samples are described in the set:
\begin{equation}
    \hat{\bm{P}}=\begin{bmatrix} \hat{\bm{p}}(k) ,\hat{\bm{p}}(k-1),\dots,\hat{\bm{p}}(k-N+1) \end{bmatrix} 
\end{equation}
Translating the data coordinates into a pseudo-static form \NB{still not clear} will create the updated set,
\begin{equation}
    \hat{\bm{P}}^*=\begin{bmatrix} \hat{\bm{p}}^*(k) ,\hat{\bm{p}}^*(k-1),\dots,\hat{\bm{p}}^*(k-N+1) \end{bmatrix} \nonumber
\end{equation}
Each element of these updated sets are calculated as,\NB{first show hoe to translate an element from one time line to another and then show the resulting vector, not viceversa}
	\begin{equation}
	\hat{\bm{p}}^*(k-i) = \hat{\bm{p}}(k-i)+\sum_{j=i}^1 v(k-j)\theta_h(k-j)t_s 
	\end{equation}
where $i=1,2,\dots,N-1$ and the most recent position estimate at time instant $k$ is unchanged from $\hat{\bm{p}}(k)$ to $\hat{\bm{p}}^*(k)$ \NB{?}. The mean of the updated set is written as $\hat{\bar{\bm{p}}}^*$, which is the estimated center point used in the calculation of the confidence region. To demonstrate how this works, Fig. \ref{fig:pseudo_static} gives a visualization of position estimates translated into a pseudo-static case. Updating \eqref{Confidence_region}, we get
    \begin{equation}
    \label{Confidence_region_updated}
		\hat{\bm{\varepsilon}}_{\hat{\bar{\bm{p}}}^*|N} = \hat{\bar{\bm{p}}}^* + c_p\frac{\sigma_p}{\sqrt{N}}
	\end{equation}
 to account for all $N-1$ translated previous data points to appear as if they all were sampled at time interval $k$.

% \begin{figure}[ht!]
% \vspace{1pt}
% \centering
% \includegraphics[width=0.48\textwidth]{pseudo_static.png}
% \caption{Translation of the original position estimates $\hat{\bm{p}}$ to a pseudo-static case $\hat{\bm{p}}^*$ as if all the position estimates were sampled from the vehicle at the current time interval $k$.}
% \label{fig:pseudo_static}
% \end{figure}


\begin{figure}[ht!]
\begin{tabular}{cc}
\subfigure[\label{fig:step_one} ]{\includegraphics[width = 0.21\textwidth]{pseudo_static_left.png}} &	
\subfigure[\label{fig:step_two} ]{\includegraphics[width = 0.21\textwidth]{pseudo_static_right.png}}
\end{tabular}
\caption{Translation of the original position estimates $\hat{\bm{p}}$ to a pseudo-static case $\hat{\bm{p}}^*$ as if all the position estimates were sampled from the vehicle at the current time interval $k$.}
\label{fig:pseudo_static}
\end{figure}



Creating a pseudo-static case with these past position data samples introduces higher uncertainty. Uncertainties regarding the velocity sensor $\sigma_v$ and heading angle sensor $\sigma_h$ need to be accounted for. To guarantee \NB{that} the true position of the vehicle is within the estimation radial bounds, the maximum error in position due to sensor noise over the furthest sample in time in $\hat{\bm{P}}^*$ is calculated as:
    \begin{align}
    \begin{split}
	\hat{\varepsilon}_{v,\theta_h|N}^{*}=\Big( &\big[(\bar{v}^* \cos{\bar{\theta}_h^*} - \bar{v}\cos{\bar{\theta}_h})(N-1)t_s \big]^2 \\
	&+ \big[ (\bar{v}^* \sin{\bar{\theta}_h^*} - \bar{v}\sin{\bar{\theta}_h})(N-1)t_s \big]^2 \Big) ^{1/2}
	\end{split}
	\end{align}
where,
    \begin{equation}
	\bar{v}^{*}=\bar{v}(k-i_{\varepsilon^{*}})+c_p\sigma_v \nonumber
	\end{equation}
    \begin{equation}
	\bar{v}=\bar{v}(k-i_{\varepsilon^{*}}) \nonumber
	\end{equation}
	\begin{equation}
	\bar{\theta}_h^{*}=\bar{\theta}_h(k-i_{\varepsilon^{*}})+c_p\sigma_h \nonumber
	\end{equation}
	\begin{equation}
	\bar{\theta}_h=\bar{\theta}_h(k-i_{\varepsilon^{*}}) \nonumber
	\end{equation}
with $i_{\varepsilon^{*}}=[1,2,,\dots,N-1]$ \NB{i is not a vector} while average measured velocity and average measured heading angles over the past $N-1$ samples of range $i_{\varepsilon^{*}}$ are denoted by $\bar{v}$ and $\bar{\theta}_h$, respectively. Doing this \NB{doing this what?}account for velocity and heading angle measurement error and ensure the vehicle's position is within our estimation region.


\subsection{Adaptive Motion Planning}

% Thus here we are interested to compute a confidence interval around our state estimation and adapt the vehicle's motion plan if safety constraints could be violated


With uncertainty of sensor measurements, with or without a reconfigured set of sensors, there needs to be guarantees to navigate safely. As the vehicle approaches undesired regions or follows a trajectory through a passageway that's more narrow than the confidence region at the current time interval $k$, we need to be able to reduce the size of estimate region \NB{not clear} to guarantee safety. The only two options are to sample data faster or reduce speed to gather more samples within a certain distance. Since sampling at a faster rate can't be done \NB{why? state due to physical limitations}, we need to slow the vehicle down to gather more data samples in a shorter distance to reduce estimation uncertainties.

To keep the vehicles estimated confidence region from intersecting with an unwanted region \NB{not clear}, a change to the number of current and past data samples in the calculation as well as an adaptation of the velocity \NB{fix grammar here}. Without uncertainty of velocity and heading angle measurements, the equation to solve for the number of required $N$ samples to keep the confidence region within a specific radius is:
    \begin{equation}
    \label{conf_region1}
	    N^* = \left(c_p \frac{ \sigma_p }{ {\min \lVert \bm{x}_r - \hat{\bar{\bm{p}}}^* \rVert} -\Delta(k) } \right)^2
	\end{equation}
where $ \min \lVert {\bm{x}_r-\hat{\bar{\bm{p}}}^*} \rVert$ is the distance from the closest undesired region to the estimated vehicle center point position $\hat{\bar{\bm{p}}}^*$.
With the assumption of normally distributed sensor noise on the velocity and heading angle sensors, the above equation is not suitable \NB{why? explain or go directly to the final results}. The uncertainty region $\hat{\varepsilon}_{v,\theta_h|N}^{*}$ from these sensors must be accounted for. The revision to equation (\ref{conf_region1}) for a sufficient value of $N$ \NB{what is sufficient here?} is:
    \begin{equation}
	    N^* = \left(c_p \frac{ \sigma_p }{ {\min \lVert \bm{x}_r - \hat{\bar{\bm{p}}}^* \rVert} -\hat{\varepsilon}_{v,\theta_h|N}^{*}-\Delta(k) } \right)^2
	\end{equation}
Due to the fact that $N^*$ represents the number of samples needed to reduce the estimation region to a desired size, $N^*$ needs to be an integer. We simply round $N^*$ up to the nearest integer to give us $N \in \N$.

An update of the reference velocity needs to occur when these undesired regions are within the entire confidence estimation region $ \hat{\varepsilon}_{\hat{\bar{\bm{p}}}^*|N} +\hat{\varepsilon}_{v,\theta_h|N}^{*}+\Delta(k)$ when $N=1$ to ensure the vehicle slows to capture more previous data samples with less estimation error \NB{not clear}. This reference velocity $r_v(k)$ update is calculated by:
    \begin{equation}
	    r_v(k)=r_v(k-1) \left[ \frac{ \min \lVert \bm{x}_r - \hat{\bar{\bm{p}}}^* \rVert - \hat{\varepsilon}_1}{\hat{\varepsilon}_2 - \hat{\varepsilon}_1} \right]
	\end{equation}
	\begin{equation}
	\begin{split}
	    \hat{\varepsilon}_1&=\hat{\bm{\varepsilon}}_{\hat{\bar{\bm{p}}}^*|N} +\hat{\varepsilon}_{v,\theta_h|N}^{*},\\ &\hat{\varepsilon}_2=\hat{\varepsilon}_1+\Delta(k) \nonumber	    
	\end{split}
	\end{equation}
	
where $\hat{\varepsilon}_1$ and $\hat{\varepsilon}_2$ are both radii from the estimated center position $\hat{\bar{\bm{p}}}^*$.
	
%	\begin{equation}
%		\Delta(k)=[v(k)]^{\delta_v}\delta
%	\end{equation}
%where $[\delta, \delta_v] \in R^{\geq0}$ are chosen values that determine the desired distance between the closest unwanted region to the estimation region as a function of velocity.


% INSERT ALGORITHM FOR REPLANNING VELOCITY
\begin{algorithm}
   \caption{Adaptive Motion for Safe Navigation} 
   \label{alg:adapt_motion} 
    \begin{algorithmic}[1]
	\State Initial conditions of system: $k=0$,$\bm{x}(0)=\bm{x}_0$
	\State Set $r_v(0)$ to desired velocity $r_{des}$
    \While{$1<k\leq\infty$}
        \State \Longunderstack[l]{ Calculate $\hat{\bar{\bm{p}}}^*$ then measure closest distance\\ to undesired region $\min \lVert \bm{x}_r - \hat{\bar{\bm{p}}}^* \rVert$.}
        \State Calculate radii of intervals $\hat{\varepsilon}_1$ and $\hat{\varepsilon}_2$ for $N$.
        \If{ $\min \lVert \bm{x}_r - \hat{\bar{\bm{p}}}^*\rVert < \hat{\varepsilon}_2(k)$}
            \State Solve for $N$ of next iteration
            \State Update reference for velocity $r_v(k)$
        \Else
            \If{$\min \lVert \bm{x}_r - \hat{\bar{\bm{p}}}^*\rVert < \hat{\varepsilon}_2(k)$ when $N=1$}
                \State Solve for $N$ of next iteration
                \State Update reference for velocity $r_v(k)$
            \Else
                \If{$r_v(k) \neq r_{des}$}
                    \State Reference velocity $r_v(k)=r_{des}$
                    \State $N = 1$
                \Else
                    \State Reference velocity $r_v(k) = r_v(k-1)$
                    \State $N = 1$
                \EndIf
            \EndIf
        \EndIf
    \EndWhile
	\end{algorithmic}
\end{algorithm}



\end{section} 