%!TEX root = ACC2019.tex

\begin{section}{Approach}
\label{sec:approach}
In this section we describe the framework for detection of sensor attacks for systems with unknown or changing dynamics and adaptive motion planning to solve Problems \ref{problem1} and \ref{problem2} and ensure vehicle's safety. We follow the architecture in the block diagram of Fig. \ref{fig:system_arch} to solve these problems. A detector monitors multiple input measurements for sensor attacks, which allows an uncompromised input $u(k)$ to control the system. At the same time, the state estimator along with the high level motion planner update the reference $r(k)$ of the controller to ensure safety. 

\begin{figure}[ht!]
\vspace{1pt}
\centering
\includegraphics[width=0.46\textwidth]{Figures/sys_arch.png}
\caption{Overall system architecture showing the relationship between the reference model adaptive controller and the adaptive motion planner.}
\label{fig:system_arch}
\end{figure}
% \NB{FIGURE: where is the adaptive controller? Group blocks together that represent the Resilient AC.}
% \NB{FIGURE: we need to have multiple arrows going out from the controller}
% \NB{FIGURE: name the motion planner differently like adaptive motion planner}

Next, we describe the framework for attack detection and sensor reconfiguration using a series of adaptive controlled subsystems.

\subsection{Resilient Adaptive Control}
\label{sec:Res_adapt_control}


In order to detect and remove attacks we propose the architecture in Fig. \ref{fig:det_arch} in which redundant sensor measurements are considered. Specifically, multiple subsystems are considered, one for each sensor measurement and within each subsystem a model reference adaptive control scheme is implemented to obtain the desired input $u^*$ to track a reference signal $y^*$. As in our previous work \cite{6943080,6843720} we assume that less than $s/2$ sensors can be compromised in order to estimate the state of the system.


% The architecture followed in this work is shown in Fig. \ref{fig:det_arch}, which consists of a subsystem for each sensor measurement within the same controlled state. Each subsystem consists of a model reference adaptive controller to generate the next input $u^*_i$ where $i=1,2,\dots,s$ given its corresponding measurement signal $y_i$.

\begin{figure}[ht!]
\centering
\includegraphics[width=0.48\textwidth]{Figures/con_and_det.png}
\caption{Architecture of the detection scheme within the adaptive controlled system. Representing  the $s$ number of available measurements, each of their adaptive subsystems generate a temporary input to be sent to the attack detector. From there, the detector removes measurement subsystems that are compromised.}
\label{fig:det_arch}
\end{figure}
%\eqref{eq:Start}$-$\eqref{eq:End}

First, to design the resilient model reference adaptive controller, we assume that:
	\begin{enumerate}%[leftmargin=3\parindent]
%	\item[$A1)$] all zeros of $B^{'}(z^{-1})z^q$ from \eqref{eq:B_prime} are within $|z|<1$. 
	\item[$A1)$] all numerator zeros of \eqref{eq:transfer_function} are within $|z|<1$.
	\item[$A2)$] $p$ and $q$ are known. 
	\item[$A3)$] the system delay $d$ is known.
	\item[$A4)$] all poles of $E(z^{-1})z^w$ from \eqref{eq:reference model_z} are within $|z|<1$.
	\end{enumerate}
The zeros $z$ of the system are within the discrete $z-plane$ while $p$, $q$, and $d$ are the dimensions of \eqref{eq:transfer_function}. With these assumptions satisfied, every $i^{th}$ subsystem can generate an input signal $u^*_i(k)$ to have its measurement signal $y_i$ track a given tracking signal $y^*$ from the reference model \eqref{eq:reference model_z}. Many of the steps to design the Characteristic Model Based all-coefficient Model Reference Adaptive Controller are omitted here, but can be found in \cite{tao2003adaptive,Goodwin1643720}. In what follows, we provide the main equations to compute the desired input when dealing with changing systems. A parameter vector of unknown coefficients describing the system's transfer function \eqref{eq:transfer_function} to follow the desired reference model is described as:
    \begin{equation}
	\bm{\theta}_0=(\alpha_0, \dots ,\alpha_{p-1},\beta_0, \dots ,\beta_{q+d-1})^T \in \R^{p+q+d}
	\end{equation}
The objective of the adaptive control is to estimate the true parameters of $\bm{\theta}_0$ with the parameter estimate vector $\bm{\theta}(k)$:
    \begin{equation}
    \bm{\theta}(k)=(\theta_1(k), \dots ,\theta_p(k),\theta_{p+1}(k), \dots ,\theta_{p+q+d}(k))^T
	\end{equation}
With our known input and measurement signals within a signal vector $\bm{\phi}(k)$,
    
	\begin{equation}
	\begin{split}
	\bm{\phi}(k)&=(y_i(k), \dots ,y_i(k-p+1),u^*_i(k), \dots , \\
	& u^*_i(k-q-d+1))^T \in \R^{p+q+d}
	\end{split}
	\end{equation}
we can estimate the true parameter vector $\bm{\theta}_0$ by updating the parameter estimate vector $\bm{\theta}(k)$ using a \textit{Modified Projection Algorithm} \cite{tao2003adaptive}:
	\begin{equation}
	\label{eq:Modified_Proj_Algorithm}
	\bm{\theta}(k)=\bm{\theta}(k-1)+\frac{a(k)\bm{\phi}(k-d)e(k)}{c+\bm{\phi}^T(k-d)\bm{\phi}(k-d)}
	\end{equation}
	\begin{equation}
	e(k)=E(z^{-1})y_i(k)-\theta^T(k-1)\bm{\phi}(k-d)
	\end{equation}
	\begin{equation}
	\epsilon<a(k)<2-\epsilon, 0,\epsilon<1, c>0 \nonumber
	\end{equation}
To follow the desired tracking output $y^*(k)$ from the reference model, the adaptive control input $u^*_i(k)$ is then calculated from the equation:
    \begin{equation}
    \label{eq:tracking_model}
	\bm{\theta}^T(k)\bm{\phi}(k)=E(z^{-1})y^*(k+d)
	\end{equation}
By rearranging \eqref{eq:tracking_model} we isolate $u^*_i(k)$ to calculate our next input signal for each $i^{th}$ subsystem for $i=1,\dots,s$:
	\begin{align}
	\label{eq:End}
	u^*_i(k)=\frac{1}{\theta_{p+1}(k)}&(-\theta_1(k)y_i(k)-\theta_2(k)y_i(k-1)  \nonumber \\
    -\dots-\theta_p(k)y_i(k&-p-1)-\theta_{p+2}(k)u^*_i(k-1)  \\
	-\theta_{p+3}(k)u^*_i(k-2)-& \dots - \theta_{p+q+d}(k)u^*_i(k-q-d+1) \nonumber \\
	+g&H(z^{-1})r(k))^T \nonumber
	\end{align}
    \begin{equation}
	\theta_{p+1}(k)\neq0 \nonumber
	\end{equation}

Once these subsystem inputs are computed, under the assumptions in (A1-A4), we leverage the following MRAC properties to detect sensor attacks when the system model is changing or unknown. In \cite{tao2003adaptive}, the following properties are found to be true when implementing an MRAC,
	\begin{enumerate}%[label=(\roman*),leftmargin=4\parindent]
	\label{assumtions_ensure}
	\item[$T1)$] $y(k)$ and $u(k)$ are bounded 
	\item[$T2)$] $\lim_{k\to\infty}(y(k)-y^*(k))=0$
	\label{Truth2}
	\item[$T3)$] $\sum_{k=0}^\infty(y(k)-y^*(k))^2<\infty$
	\end{enumerate}
where $y(k)$ is the system output and $y^*(k)$ is a tracking signal from the reference model. These properties ensure that the system's output asymptotically converges to the reference model's tracking signal in a finite amount of time. 


The resilient adaptive controller employs the architecture of redundant subsystems where each sensor measurement $y_i$ has its adaptive controller to generate an input $u^*_i$ to follow a desired tracking signal $y^*_i$. Each of the sensor measurements, when uncompromised, have convergence (T2) towards their desired tracking signal from the corresponding reference model,
    \begin{equation}
    \label{multiple_output_tracking}
    \lim_{k\to\infty}(y_i(k)-y^*_i(k))=0, \;\;\; i=1,\dots,s
    \end{equation}

\eqref{multiple_output_tracking} remains true with a changing reference signal $r(k)$, changing dynamics, or bounded disturbances. 

% Each MRAC subsystem calculates an input $u^*_i(k)$ that is fed into the detector, which analyses each to check for attacks. 

Since \eqref{multiple_output_tracking} should hold during any operation, the following equation is also true:
\begin{equation}
    \label{eq:u_to_0}
    \lim_{k\to\infty}(u^*_i(k)-u^*_j(k))=0, \text{ }i\neq j
\end{equation}
\begin{equation}
    i,j = 1,\dots,s \nonumber
\end{equation}
where $u^*_i$ and $u^*_j$ refer to inputs calculated from their respected subsystems to track the same signal $y_i^*(k)$. Each subsystem input while under ideal conditions (i.e., considering perfect measurements with no noise), should converge to the same value as all other inputs. For each subsystem to compute the next input $u^*_i(k)$, its sensor measurement $y_i$ needs to be uncompromised. As a measurement is corrupted due to a non-zero element from the sensor attack vector, the corresponding subsystem's computed input diverges from the remaining inputs. Mathematically, to detect attacks, a difference matrix $\bm{\Psi}(k)$ is designed for every time interval $k$ of each controlled state. The structure of this matrix is,
    \begin{equation}
    \label{eq:difference_matrix}
	\bm{\Psi}(k)=\begin{bmatrix} \psi_{1,1}(k) & \psi_{1,2}(k) & \dots & \psi_{1,s}(k) \\ \psi_{2,1}(k) & \psi_{2,2}(k) &  &  \\ \vdots &  & \ddots &  \\ \psi_{s,1}(k) &  &  & \psi_{s,s}(k) \end{bmatrix}
	\end{equation}
where $\bm{\Psi}(k) \in \R^{s\times s}$. Each element $\psi_{i,j}\in\bm{\Psi}$ is an error computed as the absolute difference between two subsystem inputs:
    \begin{equation}
        \label{eq:input_diff}
        \psi_{i,j}(k)=|u^*_i(k)-u^*_j(k)|
    \end{equation}
The $l_1$ vector norm for each row in \eqref{eq:difference_matrix} is computed giving the following vector:
    \begin{equation}
    \label{eq:difference_vector}
	\bm{\Psi^{'}}(k)=\begin{bmatrix} \lVert{\bm{\Psi}_1(k)}\rVert_1 \\ \lVert{\bm{\Psi}_2(k)}\rVert_1 \\ \vdots \\ \lVert{\bm{\Psi}_s(k)}\rVert_1 \end{bmatrix}
	\end{equation}
The minimum value element of \eqref{eq:difference_vector} is used to form another vector $\bm{\Psi}^{'}_{min}(k) \in \R^s$, with every element equal to $\min \bm{\Psi}^{'}(k)$:
%     \begin{equation}
% 	\bm{\Psi}^{'}_{min}(k)=\begin{bmatrix} \min \bm{\Psi}^{'}(k),& \dots \text{ },&\min \bm{\Psi}^{'}(k) \end{bmatrix}^T
% 	\end{equation}
    \begin{equation}
	\bm{\Psi}^{'}_{min}(k)=\min \bm{\Psi}^{'}(k){\bm{1}}_s
	\end{equation}
	where ${\bm{1}}_s$ is a $s\times1$ vectors of 1s.

We can now define the updated error vector as:
    \begin{align}
    \label{eq:Psi2}
	\bm{\Psi}^{''}(k)&=\bm{\Psi}^{'}(k)-\bm{\Psi}^{'}_{min}(k) \\
	& =\begin{bmatrix} \lVert{\bm{\Psi}_1(k)}\rVert_1 - \min \bm{\Psi}^{'}(k)\\ \lVert{\bm{\Psi}_2(k)}\rVert_1 - \min \bm{\Psi}^{'}(k) \\ \vdots \\ \lVert{\bm{\Psi}_s(k)}\rVert_1 - \min \bm{\Psi}^{'}(k) \end{bmatrix}
	\end{align}
	
From \eqref{eq:u_to_0} while under ideal conditions (i.e., with no noise), the error vector \eqref{eq:Psi2} has all elements equal to zero. When an $i^{th}$ sensor is under attack, the $i^{th}$ input diverges from the remaining uncompromised inputs. The $i^{th}$ element of $\bm{\Psi}^{''}(k)$ becomes non-zero due to the compromised sensor, while the rest of the elements remain zero. 

Under non-ideal conditions where noises exist, the elements of the error vector will not remain zero while sensors are uncompromised. By setting a threshold value $\delta$, all elements of the error vector need to stay below this level. By refining \eqref{eq:Psi2} for non-ideal conditions we get,
    \begin{align}
    \begin{split}
    \label{eq:Psi2_nonideal}
	\bm{\Psi^{''}}(k)&=\bm{\Psi^{'}}(k)-\bm{\Psi}^{'}_{min}(k) \\
	& =\begin{bmatrix} \lVert{\bm{\Psi}_1(k)}\rVert_1 - \min \bm{\Psi}^{'}(k)\\ \lVert{\bm{\Psi}_2(k)}\rVert_1 - \min \bm{\Psi}^{'}(k) \\ \vdots \\ \lVert{\bm{\Psi}_s(k)}\rVert_1 - \min \bm{\Psi}^{'}(k) \end{bmatrix} \leq \bm{\delta}(k)
	\end{split}
	\end{align}
in which the vector $\bm{\delta}(k) \in \R^s$ has elements all equal to the scalar value $\delta(k)$, which is computed from the measurement with the highest noise profile $\sigma_{max}$. The value of $\delta(k)$ is computed from the system parameter estimates and the maximum error due to measurement uncertainty. The maximum error due to the least precise sensor is computed as:
	\begin{equation}
	    \label{eq:max_error}
	    e_{max} = 2N_{\sigma}\sigma_{max}
	\end{equation}
From \eqref{eq:End} and \eqref{eq:max_error}, we can compute the bound for the maximum uncertainty of the input:
\begin{align}
	\label{eq:delta}
	\delta(k)=& \lVert{ \frac{1}{\theta_{p+1}(k)}(-\theta_1(k)e_{max}-\theta_2(k)e_{max} }-\dots \nonumber \\
    -\theta_p(k)&e_{max}-\theta_{p+2}(k)u(k-1)-\theta_{p+3}(k)u(k-2)  \\
	&- \dots - \theta_{p+q+d}(k)u(k-q-d+1) \rVert  \nonumber
	\end{align}
However, using the aforementioned approach, an attack that is hiding within the noise profile may be undetectable. To deal with stealthy attacks within the noise, the mean of $N_p$ number of inputs is computed. To detect stealthier attacks, the same steps from equations \eqref{eq:difference_matrix}-\eqref{eq:delta} are taken with two alterations. \eqref{eq:input_diff} is reformulated as:
    \begin{equation}
        \label{eq:input_diff2}
        \psi_{i,j}(k)=|\bar{u}^*_i(k)-\bar{u}^*_j(k)|
    \end{equation}
where,
    \begin{equation}
        \label{eq:Average_input}
        \bar{u}^*_i(k) = \sum_{j=0}^{N_p-1} \frac{u^*_i(k-j)}{N_p}
    \end{equation}
is the mean of the past $N_p$ subsystem inputs. The other alteration is the computation of \eqref{eq:max_error} for a smaller error threshold. A standard maximum error is computed when $N_p>1$ as:
    \begin{equation}
	    \label{eq:max_error2}
	    e_{max} = \frac{2N_s\sigma_{max}}{\sqrt{N_p}}
	\end{equation}
The error threshold bound in \eqref{eq:delta} is reduced to find attacks that have the objective to slowly push the measurement signal away while remaining within the noise profile. A trade-off is made when determining the size of $N_p$: A larger number allows for a higher reduction of the error threshold, but may allow for attacks to remain undetected if the attack occurs for a smaller time frame than the detection window $N_pt_s$.

If a $i^{th}$ subsystem input breaks the error threshold, its corresponding $i^{th}$ sensor is removed from the system and placed into the set $\bm{y}_a$. After detecting and removing the compromised sensors, the updated measurement matrix reduces in size to $\bm{C}' \in \R^{s' \times n}$ with $s'=s-s_a$ and the measurement set becomes $\bm{y}' =\bm{y}\setminus\bm{y}_a$. Finally, once the subsystem inputs $u_i^*(k)$ have been checked by the detector, the remaining uncompromised measurements are fused and then directed to an adaptive controller to compute an input $u(k)$ for the system.

\begin{lemma} 
	\label{lemma_1}
	Using \eqref{eq:Psi2_nonideal} and \eqref{eq:End}, a system \eqref{eq:discrete_SS} is guaranteed to remain stable and maintain tracking with dynamical changes, disturbances, and sensor attacks. 
%	By using input technique \eqref{eq:End} while the attack detector \eqref{eq:Psi2_nonideal} is operating, the output converges to the tracking signal from one time instance $k$ to the next $k+1$.

\end{lemma}

\begin{proof}
The proof is intuitive and follow a similar argument as presented in \cite{tao2003adaptive}. Under the assumptions (A1-A4) and the convergence property from \eqref{eq:Modified_Proj_Algorithm},
    \begin{equation}
    \label{lemma_1_eq1}
        \lim_{k\to\infty}\|\bm{\theta}(k)-\bm{\theta}_0\|=0 \nonumber
    \end{equation}
the properties (T1-T3) also hold true. If $e(k)$ is a bounded value for all time instances $k$, then the signal vector $\lVert{\bm{\phi}}(k) \rVert$ is also bounded over time. As an attacker hijacks a measurement, \eqref{eq:Psi2_nonideal} ensures a measurement signal never becomes unbounded or diverges above the error threshold \eqref{eq:delta} for all time instances $k$. By removing compromised measurements, $\lVert{\bm{\phi}}(k) \rVert$ remains bounded, guaranteeing stability and tracking of the desired reference signal.
  
\end{proof}







% 	If the following conditions are satisfied over the sequence in time:
%     \begin{enumerate}[label=(\roman*),leftmargin=1\parindent]
%     \item
%     \begin{equation}
%     \label{lemma_1_eq1}
%         \lim_{k\to\infty}\frac{e(k)}{c+\bm{\phi}^T(k)\bm{\phi}(k)}=0
%     \end{equation}
%     where $c$ and $e(k)$ are real scalar values and $\bm{\phi} \in \R^{p \times 1}$ 
%     \item Linear boundedness conditions 
%     \begin{equation}
%     \label{lemma_1_eq2}
%         \lVert{\bm{\phi}} \rVert < C_1 + C_2 \max|s(t)|
%     \end{equation}
% where $0<C_1<\infty$ and $0<C_2<\infty$, the following is true,
%     \begin{enumerate}[label=(\roman*),leftmargin=3\parindent]
%         \item $\lim_{k\to\infty}e(k) = 0$ \\
%         \item $\lVert{\bm{\phi}}(k) \rVert$ is bounded
%     \end{enumerate}
% \end{enumerate}


% DO I NEED THIS?

%Properties of the modified projection algorithm \eqref{eq:Modified_Proj_Algorithm} include:
%    \begin{enumerate}[label=(\roman*),leftmargin=3\parindent]
%	\item every iteration improves estimation:
%	    \begin{align}
%	        \|\bm{\theta}(k)-\bm{\theta}_0\|\leq\|\bm{\theta}(k-1)-\bm{\theta}_0\|, k\geq1 \nonumber
%	    \end{align}
%	\item parameter variation converges to zero:
%	    \begin{align}
%	        \lim_{k\to\infty}(\bm{\theta}(k)-\bm{\theta}(k-N))=0, \text{any finite } N>0 \nonumber
%	    \end{align}
%	\end{enumerate}
	

\subsection{Estimation Confidence} 

The presence of measurement noise on the sensor set results in state estimation uncertainty. The vehicle has multiple sensors of various noise profiles that provide state data of the system, some of which are fused to obtain a better estimation. As compromised sensors are removed by the detector, the system uses a smaller set of sensors for state estimation obtaining a different uncertainty from the original set of measurements. Thus, to take into account this change in sensor measurement noises, we propose here an approach to compute confidence around state estimation to ensure vehicle safety. 
%In this work we develop a technique to assess confidence around state estimation that adapts to the changing sensor set to ensure vehicle safety. 
We leverage the statistical technique of confidence intervals \cite{devore2011probability} to obtain a specific confidence of an estimate. Confidence intervals are used to calculate bounds in which the true mean lies within of a user-defined confidence percentage. By knowing the confidence percentage $c_p$, population standard deviation $\sigma$, the number of sensor data samples $N$, and the mean of the $N$ sensor data samples $\bar{x}$, an interval is computed:
    \begin{equation}
     \label{Confidence_interval}
		C_x = \bar{x} + c_p\frac{\sigma}{\sqrt{N}}
	\end{equation}
	
% . As the number of data samples increases, the confidence interval shrinks in size to give a better estimation of the true mean \NB{you are giving the results before showing how!}	
	
For state estimation with sensor uncertainties, we need to guarantee that the vehicle is within a region of confidence to prevent entering into an undesired state. Uncompromised sensor measurements from the set $\bm{y}$ are fused using filtering techniques (e.g. Kalman Filtering) and the result is an estimate with variance $\sigma_p^2$, which depends on each sensor variance. In our specific case, a multivariate confidence interval is computed to create a confidence region for position $\bm{p}=[x,y]^T$ estimation. 
% position estimate $\bm{p}=[x,y]^T$ of a certain 
%This states the vehicle is within the computed region of a specific confidence percentage. 


The estimated position data has the form $\mathcal{N}(0,\sigma_p)$ where the data's population standard deviation $\sigma_p$ changes depending on the combination of sensors (i.e., when the system is uncompromised and we are using all sensors, $\sigma_p$ is lower than the case with fewer sensors, after an attack is removed from the system). In our work we are interested in position estimate and thus \eqref{Confidence_interval} in a multivariate case becomes,
    \begin{equation}
    \label{Confidence_region}
		C_{\bar{\bm{p}}|N_e} = \bar{\bm{p}} + c_p\frac{\sigma_p}{\sqrt{N_e}}
	\end{equation}
with $c_p$ defining the value for a specific confidence percentage, which can be found from tables in \cite{devore2011probability} and $\bar{\bm{p}}$ is the mean position estimate from the $N_e$ data samples. The radius of the multivariate confidence region \eqref{Confidence_region} from the center point $\bar{\bm{p}}$ is:
    \begin{equation}
    \label{Confidence_radius}
		C_r = c_p\frac{\sigma_p}{\sqrt{N_e}}
	\end{equation}
From \eqref{Confidence_radius}, it is clear that with a larger number of $N$ data samples, the radius of the confidence region becomes smaller. Similar to the calculation of confidence intervals \eqref{Confidence_interval}, the true mean is assumed static (i.e. is not changing over time). 
%This cannot be assumed in the case of position estimation of a moving vehicle. 

% \begin{figure}[ht!]
% \vspace{1pt}
% \centering
% \includegraphics[width=0.48\textwidth]{Gaussian2D.png}
% \caption{Distribution of vehicle's estimated position over 100 samples in an $X-Y$ plane with equal noise variance on the $X$ and $Y$ axis. Creating a psuedo-static case allows for the calculation of a confidence region for vehicle position.}
% \label{fig:gauss_pdf}
% \end{figure}


\begin{figure}[ht!]
\begin{tabular}{cc}
\subfigure[\label{fig:1sample} ]{\includegraphics[width = 0.22\textwidth]{Figures/sample1.png}} &	
\subfigure[\label{fig:5samples} ]{\includegraphics[width = 0.22\textwidth]{Figures/sample5.png}}
\end{tabular}
\caption{A comparison of the size of the estimated confidence region as the $N_e$ number of data samples grow. In \ref{fig:1sample}, the estimated confidence region with 1 data sample is not as accurate. In \ref{fig:5samples}, the $N_e$ number of samples used is five, which gives a much smaller size and more accurate confidence region.}
\label{fig:confidence_region}
\end{figure}

To take vehicle mobility into account, we propose an adapted approach to compute the confidence region using previous estimated position measurements $\bm{p}(k-i)$, where $i=1,\dots,N_e-1$. These $N_e-1$ number of previous measurements need to be represented as if they were all sampled for the current position in time $k$, creating a pseudo-static set of data. As shown in Fig. \ref{fig:confidence_region}, using a static set of measurements, we are able to calculate a confidence region using more than one sample to improve estimation accuracy. The $N_e$ position estimate samples are described in the set:
\begin{equation}
    \bm{P}=\begin{bmatrix} \bm{p}(k) ,\bm{p}(k-1),\dots,\bm{p}(k-N+1) \end{bmatrix} 
\end{equation}
To compute the static case, we need to translate the elements forward with the following transformation:
	\begin{equation}
	\bm{p}^*(k-i) = \bm{p}(k-i)+\sum_{j=i}^1 v(k-j)\theta_h(k-j)t_s 
	\end{equation}
where $i=1,\dots,N_e-1$. Translating the data coordinates into a static form creates the updated set,
\begin{equation}
    \bm{P}^*=\begin{bmatrix} \bm{p}^*(k) ,\bm{p}^*(k-1),\dots,\bm{p}^*(k-N_e+1) \end{bmatrix} \nonumber
\end{equation}
The mean of the updated set is written as $\bar{\bm{p}}^*$, which is the estimated center point used in the calculation of the confidence region. Fig. \ref{fig:pseudo_static} gives a visualization of the procedure used to translate forward position estimates and obtain pseudo-static case. Updating \eqref{Confidence_region}, we get
    \begin{equation}
    \label{Confidence_region_updated}
		C_{\bar{\bm{p}}^*|N_e} = \bar{\bm{p}}^* + c_p\frac{\sigma_p}{\sqrt{N_e}}
	\end{equation}
 to account for all $N-1$ translated previous data points to appear as if they all were sampled at time interval $k$.

% \begin{figure}[ht!]
% \vspace{1pt}
% \centering
% \includegraphics[width=0.48\textwidth]{pseudo_static.png}
% \caption{Translation of the original position estimates $\hat{\bm{p}}$ to a pseudo-static case $\hat{\bm{p}}^*$ as if all the position estimates were sampled from the vehicle at the current time interval $k$.}
% \label{fig:pseudo_static}
% \end{figure}


\begin{figure}[ht!]
\begin{tabular}{cc}
\subfigure[\label{fig:step_one} ]{\includegraphics[width = 0.21\textwidth]{Figures/pseudo_static_left.png}} &	
\subfigure[\label{fig:step_two} ]{\includegraphics[width = 0.21\textwidth]{Figures/pseudo_static_right.png}}
\end{tabular}
\caption{Translation of the original position estimates $\bm{p}$ to a static case $\bm{p}^*$ as if all the position estimates were sampled from the vehicle at the current time interval $k$.}
\label{fig:pseudo_static}
\end{figure}


Creating a static case with these past position data samples introduces higher uncertainty. Uncertainties regarding the velocity sensor $\sigma_v$ and heading angle sensor $\sigma_h$ need to be accounted for. To guarantee that the true position of the vehicle is within the estimation radial bounds, the maximum error in position due to sensor noise over the furthest sample in time in $\bm{P}^*$ is calculated as:
    \begin{align}
    \begin{split}
	&\epsilon_{v,\theta}=\Big( \big[(\bar{v}^* \cos(N_{\sigma}\sigma_h) - \bar{v}) \big]^2 \\
	+ & \big[ (\bar{v}^* \sin(N_{\sigma}\sigma_h) - 0) \big]^2 \Big) ^{1/2} (N_e-1)
	\end{split}
	\end{align}
    \begin{equation}
    \label{eq:avg_vel}
    \bar{v}=\sum_{j=0}^{N_e-1} \frac{v(k-j)}{N_e}
	%\bar{v}^{*}=\bar{v}(k-i_{C^{*}})+c_p\sigma_v \nonumber
	\end{equation}
    \begin{equation}
    \label{eq:avg_vel_noise}
	\bar{v}^{*}=\bar{v}+N_{\sigma}\sigma_v 
	\end{equation}
\NB{this previous part is too specific.We should probably remove it. Let's talk about this later}The maximum angle error is denoted as $N_{\sigma}\sigma_h$ \NB{what is N times sigma???} and the average velocity with and without sensor error are computed in \eqref{eq:avg_vel} and \eqref{eq:avg_vel_noise}. The worst case scenario is assumed in the both the velocity and angle measurement error. Including the uncertainty due to velocity and angle measurements, the confidence region from \eqref{Confidence_region_updated} is updated to,
    \begin{equation}
    \label{Confidence_region_updated2}
		C_{\bar{\bm{p}}^*|N_e} = \bar{\bm{p}}^* + c_p\frac{\sigma_p}{\sqrt{N_e}} + \epsilon_{v,\theta}
	\end{equation}
with a radius of:
    \begin{equation}
    \label{Confidence_radius2}
		C_r = c_p\frac{\sigma_p}{\sqrt{N_e}} + \epsilon_{v,\theta}
	\end{equation}

\subsection{Adaptive Motion Planning}

% Thus here we are interested to compute a confidence interval around our state estimation and adapt the vehicle's motion plan if safety constraints could be violated

Using the approach just  described, we can increase confidence in the state estimation by gathering more data when necessary and guarantee safety. For example a vehicle in an open space far from obstacles, doesn't need a very accurate state estimation to guarantee safety, while the same vehicle in a cluttered environment may need more accuracy and thus more samples to precisely estimate its position.

%With uncertainty of sensor measurements, with or without a reconfigured set of sensors, there needs to be guarantees to navigate safely. As the vehicle approaches an undesired region, we need to gather more data to reduce the size of the confidence region to guarantee safety. 

To gather more data there are two options: i) to sample data faster or ii) to reduce velocity. However, sampling at a faster rate cannot be done due to physical limitations, hence adapting the velocity of the vehicle is the only way to gather more data in a shorter distance to reduce estimation uncertainties. 
%To ensure the confidence region never intersects with an undesired state (e.g., an obstacle), we update the number of data samples for better estimation while also adapting the velocity.

Due to uncertainty of the measurements, the confidence region can quickly shift as new measurements are sampled. To counteract this shifting, a boundary around the confidence region is computed as:
    \begin{equation}
    \label{eq:Delta}
	    \Delta(k) = 2\big(c_p\frac{\sigma_p}{\sqrt{N_e}} + \epsilon_{v,\theta}\big) = 2C_{\bar{\bm{p}}^*|N_e}
	\end{equation}
which is the maximum distance the region can shift for any time.\NB{this previous part is not necessary and too detailed. We will probably remove it. let's talk later about this}

To update the confidence region, we compute the distance the vehicle can travel to the next time interval $d_p$. The distance $d_p$ is computed in a worst case scenario, as if the vehicle navigates in the direction of the nearest undesired state $\min \lVert \bm{x}_o - \bar{\bm{p}}^*(k+1)^* \rVert$. At the next predicted state $\bm{x}^*(k+1)$, \NB{what is x and what is p???}if an undesired region is within $C_{\bar{\bm{p}}^*|N_e} + \Delta(k)$, the next value of $N_e$ is computed by:
    \begin{equation}
    \label{eq:N_e}
	    N_e = round \left(c_p \frac{ \sigma_p }{ {\min \lVert \bm{x}_o - \bar{\bm{p}}^*(k+1) \rVert} -\Delta(k) } \right)^2
	\end{equation}
where $round$, rounds $N_e$ up to the nearest integer.
%Due to the fact that $N_e$ represents the number of samples needed to reduce the estimation region to a desired size, we simply round $N_e$ up to the nearest integer to give us $N_e \in \N$.

An update of the reference velocity needs to occur when these undesired states are within the confidence region $ C_{\bar{\bm{p}}^*|N_e}+\Delta(k)$. Slowing down allows us to capture more previous data samples with less estimation error. This reference velocity $r_v(k)$ update is calculated as: \NB{as: not by,...be consistent with punctuations}
\NB{no, next part needs more work..let's talk later}
    \begin{equation}
    \label{eq:ref_vel}
        r_v(k) = \min\{\Tilde{r}_v(k), \bar{r}_v(k) ,r_{des}(k)\}
	\end{equation}
where $r_{des}(k)$ is the desired reference and,
	\begin{equation}
	    \Tilde{r}_v(k) = \frac{d_x}{N_et_s}, \;\;\;\; \bar{r}_v(k) = \frac{\delta_{\Delta}}{t_s}
	\end{equation}
	\begin{equation}
	    \delta_{\Delta} = \min \lVert \bm{x}_o - C_r \rVert 
	\end{equation}
are maximum allowable velocities according to the distance of an undesired state to the confidence region. As we compute the minimum velocity of $\min\{\Tilde{r}_v,\bar{r}_v,r_{des}(k)\}$, we ensure a velocity to safely navigate without entering an undesired state.

\begin{lemma} 
	\label{lemma_2}
Using ...a vehicle is guaranteed to never enter an undesired state $\bm{x}_o$ between two consecutive states $\bm{x}(k)$ and $\bm{x}(k+1)$

%Given two consect $\bm{x}(k)$, the vehicle's next state $\bm{x}(k+1)$ will never enter an undesired state $\bm{x}_o$.

\end{lemma}

\begin{proof}
With the vehicle at the state $\bm{x}(k) \neq \bm{x}_o$, there exists a reference velocity $r(k)$ such that the vehicle's next state $\bm{x}(k+1)$ will never overlap into an undesired region $\bm{x}_o$. Using \eqref{eq:N_e}, the required number of data samples are computed to guarantee the confidence region \eqref{Confidence_region_updated2} of the next state $\bm{x}(k+1)$ will never intersect with an undesired state:
\begin{equation}
    C_{\bar{\bm{p}}^*(k+1)|N_e} \cap \bm{x}_o = \emptyset \nonumber
\end{equation}
Assuming the knowledge of velocity $v(k)$ and distance to the closest obstacle $\min \lVert \bm{x}_o - \bar{\bm{p}}^*(k) \rVert$, the reference velocity \eqref{eq:ref_vel} is computed such that the vehicle will not travel more than a distance $d_p$ to avoid an undesired state:
\begin{equation}
    \min \lVert \bm{x}_o - C_r \rVert > d_p \geq r_v(k)t_s \nonumber
  \nonumber
\end{equation}
The system uses a closed loop controller to always converge toward the trajectory with the assumption that the trajectory never crosses through an undesired state.
\end{proof}
%	\begin{equation}
%		\Delta(k)=[v(k)]^{\delta_v}\delta
%	\end{equation}
%where $[\delta, \delta_v] \in R^{\geq0}$ are chosen values that determine the desired distance between the closest unwanted region to the estimation region as a function of velocity.




% % INSERT ALGORITHM FOR REPLANNING VELOCITY
% \begin{algorithm}
%   \caption{Adaptive Motion for Safe Navigation} 
%   \label{alg:adapt_motion} 
%     \begin{algorithmic}[1]
% 	\State Initial conditions of system: $k=0$,$\bm{x}(0)=\bm{x}_0$
% 	\State Set $r_v(0)$ to desired velocity $r_{des}$
%     \While{$1<k\leq\infty$}
%         \State \Longunderstack[l]{ Calculate $\bar{\bm{p}}^*$ then measure closest distance\\ to undesired region $\min \lVert \bm{x}_r - \bar{\bm{p}}^* \rVert$.}
%         \State Calculate radii of intervals $\varepsilon_1$ and $\varepsilon_2$ for $N$.
%         \If{ $\min \lVert \bm{x}_r - \bar{\bm{p}}^*\rVert < \varepsilon_2(k)$}
%             \State Solve for $N$ of next iteration
%             \State Update reference for velocity $r_v(k)$
%         \Else
%             \If{$\min \lVert \bm{x}_r - \bar{\bm{p}}^*\rVert < \varepsilon_2(k)$ when $N=1$}
%                 \State Solve for $N$ of next iteration
%                 \State Update reference for velocity $r_v(k)$
%             \Else
%                 \If{$r_v(k) \neq r_{des}$}
%                     \State Reference velocity $r_v(k)=r_{des}$
%                     \State $N = 1$
%                 \Else
%                     \State Reference velocity $r_v(k) = r_v(k-1)$
%                     \State $N = 1$
%                 \EndIf
%             \EndIf
%         \EndIf
%     \EndWhile
% 	\end{algorithmic}
% \end{algorithm}



\end{section} 