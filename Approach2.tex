%!TEX root = ACC2019.tex

\begin{section}{Approach}
\label{sec:approach}
In this section we describe the framework for detection of sensor attacks for systems with unknown or changing dynamics and adaptive motion planning to solve Problems \ref{problem1} and \ref{problem2} and ensure vehicle's safety. We follow the architecture in the block diagram of Fig. \ref{fig:system_arch} to solve these problems. A detector monitors sensor measurements and calculates inputs for sensor attacks, which allows an uncompromised input $u(k)$ to control the system. \NB{no from the figure the detector is receiving inputs and returning one input } At the same time, the state estimator along with the high level motion planner update the reference $r(k)$ of the controller to ensure safety. 

\begin{figure}[ht!]
\vspace{1pt}
\centering
\includegraphics[width=0.46\textwidth]{Figures/sys_arch.png}
\caption{Overall system architecture showing the relationship between the reference model adaptive controller and the adaptive motion planner.}
\label{fig:system_arch}
\end{figure}
\NB{FIGURE: where is the adaptive controller? Group blocks together that represent the Resilient AC.}
\NB{FIGURE: we need to have multiple arrows going out from the controller}
\NB{FIGURE: name the motion planner differently like adaptive motion planner}

Next, we describe the framework for attack detection and sensor reconfiguration problems using a series of adaptive controlled systems.

\subsection{Resilient Adaptive Control}
\label{sec:Res_adapt_control}


In order to detect and remove attacks we propose the architecture in Fig. \ref{fig:det_arch} in which redundant sensor measurements are considered. Specifically, multiple subsystems are considered, one for each sensor measurement and within each subsystem a model reference adaptive control scheme is implemented to obtain the desired input $u^*$ to track a reference signal $y^*$. As in our previous work \cite{6943080,6843720} we assume that less than $s/2$ sensors can be compromised in order to estimate the state of the system.


% The architecture followed in this work is shown in Fig. \ref{fig:det_arch}, which consists of a subsystem for each sensor measurement within the same controlled state. Each subsystem consists of a model reference adaptive controller to generate the next input $u^*_i$ where $i=1,2,\dots,s$ given its corresponding measurement signal $y_i$.

\begin{figure}[ht!]
\vspace{1pt}
\centering
\includegraphics[width=0.48\textwidth]{Figures/con_and_det.png}
\caption{Architecture of the detection scheme within the adaptive controlled system. Representing  the $s$ number of available measurements, each of their adaptive subsystems generate a temporary input to be sent to the attack detector. From there, the detector removes measurement subsystems that are compromised.}
\label{fig:det_arch}
\end{figure}
%\eqref{eq:Start}$-$\eqref{eq:End}

First, to design the resilient model reference adaptive controller, we assume that:
	\begin{enumerate}[leftmargin=3\parindent]
%	\item[$A1)$] all zeros of $B^{'}(z^{-1})z^q$ from \eqref{eq:B_prime} are within $|z|<1$. 
	\item[$A1)$] all numerator zeros of \eqref{eq:transfer_function} are within $|z|<1$.
	\item[$A2)$] $p$ and $q$ are known. 
	\item[$A3)$] the system delay $d$ is known.
	\item[$A4)$] all poles of $E(z^{-1})z^w$ from \eqref{eq:reference model_z} are within $|z|<1$.
	\end{enumerate}
The zeros $z$ of the system are within the discrete $z-plane$ while $p$, $q$, and $d$ are the dimensions of \eqref{eq:transfer_function}. With these assumptions satisfied, every $i^{th}$ subsystem can generate an input signal $u^*_i(k)$ to have its measurement signal $y_i$ track a given tracking signal $y^*$ from the reference model \eqref{eq:reference model_z}. Many of the steps to design the Characteristic Model Based all-coefficient Model Reference Adaptive Controller are omitted here, which can be found in \cite{tao2003adaptive,Goodwin1643720}, however we provide the main equations to compute the next input. A parameter vector of unknown coefficients describing the system's transfer function \eqref{eq:transfer_function} to follow the desired reference model is described as:
    \begin{equation}
	\bm{\theta}_0=(\alpha_0, \dots ,\alpha_{p-1},\beta_0, \dots ,\beta_{q+d-1})^T \in \R^{p+q+d}
	\end{equation}
The objective of the adaptive control is to estimate the true parameters of $\bm{\theta}_0$ with the parameter estimate vector $\bm{\theta}(k)$:
    \begin{equation}
    \bm{\theta}(k)=(\theta_1(k), \dots ,\theta_p(k),\theta_{p+1}(k), \dots ,\theta_{p+q+d}(k))^T
	\end{equation}
With our known input and measurement signals within a signal vector $\bm{\phi}(k)$,
    
	\begin{align}
	\begin{split}
	\bm{\phi}(k)&=(y_i(k), \dots ,y_i(k-p+1),u^*_i(k), \dots , \\
	& u^*_i(k-q-d+1))^T \in \R^{p+q+d}
	\end{split}
	\end{align}
we can estimate the true parameter vector $\bm{\theta}_0$ by updating the parameter estimate vector $\bm{\theta}(k)$ using a \textit{Modified Projection Algorithm} \cite{tao2003adaptive}:
	\begin{equation}
	\label{eq:Modified_Proj_Algorithm}
	\bm{\theta}(k)=\bm{\theta}(k-1)+\frac{a(k)\bm{\phi}(k-d)e(k)}{c+\bm{\phi}^T(k-d)\bm{\phi}(k-d)}
	\end{equation}
	\begin{equation}
	e(k)=E(z^{-1})y_i(k)-\theta^T(k-1)\bm{\phi}(k-d)
	\end{equation}
	\begin{align*}
	\epsilon<a(k)<2-\epsilon, 0,\epsilon<1, c>0
	\end{align*}
To follow the desired tracking output $y^*(k)$ from the reference model, the adaptive control input $u^*_i(k)$ is then calculated from the equation:
    \begin{equation}
    \label{eq:tracking_model}
	\bm{\theta}^T(k)\bm{\phi}(k)=E(z^{-1})y^*(k+d)
	\end{equation}
By rearranging \eqref{eq:tracking_model} we isolate $u^*_i(k)$ to calculate our next input signal for each $i^{th}$ subsystem for $i=1,2,\dots,s$:
	\begin{align}
	\label{eq:End}
	u^*_i(k)=\frac{1}{\theta_{p+1}(k)}&(-\theta_1(k)y_i(k)-\theta_2(k)y_i(k-1)  \nonumber \\
    -\dots-\theta_p(k)y_i(k&-p-1)-\theta_{p+2}(k)u^*_i(k-1)  \\
	-\theta_{p+3}(k)u^*_i(k-2)-& \dots - \theta_{p+q+d}(k)u^*_i(k-q-d+1) \nonumber \\
	+g&H(z^{-1})r(k))^T \nonumber
	\end{align}
    \begin{equation}
	\theta_{p+1}(k)\neq0 \nonumber
	\end{equation}

Once these subsystem inputs are computed, under the assumptions in (A1-A4), we leverage the following MRAC properties to detect sensor attacks when the system model is changing or unknown. In \cite{tao2003adaptive}, the following properties are found to be true when implementing an MRAC,
	\begin{enumerate}[label=(\roman*),leftmargin=4\parindent]
	\label{assumtions_ensure}
	\item[$T1)$] $y(k)$ and $u(k)$ are bounded 
	\item[$T2)$] $\lim_{k\to\infty}(y(k)-y^*(k))=0$
	\label{Truth2}
	\item[$T3)$] $\sum_{k=0}^\infty(y(k)-y^*(k))^2<\infty$
	\end{enumerate}
where $y(k)$ is the system output and $y^*(k)$ is a tracking signal from the reference model. This ensures the system's output asymptotically converges to the reference model's tracking signal in a finite amount of time. 


The resilient adaptive controller employs the architecture of redundant subsystems where each sensor measurement $y_i$ has its adaptive controller to generate an input $u^*_i$ to follow a desired tracking signal $y^*_i$. Each of the sensor measurements, when uncompromised, have convergence (T2) towards their desired tracking signal from the corresponding reference model,
    \begin{equation}
    \label{multiple_output_tracking}
    \lim_{k\to\infty}(y_i(k)-y^*_i(k))=0
    \end{equation}
for $i=1,2,\dots,s$. This remains true with a changing reference signal $r_i(k)$, changing dynamics, or bounded disturbances. 

% Each MRAC subsystem calculates an input $u^*_i(k)$ that is fed into the detector, which analyses each to check for attacks. 

Since \eqref{multiple_output_tracking} should hold during any operation, the following equation is also true:
\begin{equation}
    \label{eq:u_to_0}
    \lim_{k\to\infty}(u^*_i(k)-u^*_j(k))=0, \text{ }i\neq j
\end{equation}
\begin{equation}
    i,j = 1,2,\dots,s \nonumber
\end{equation}
where $u^*_i$ and $u^*_j$ refer to inputs calculated from their respected subsystems to track the same signal $y_i^*(k)$. Each input while under ideal conditions (i.e., considering perfect measurements with no noise), should be the same value as all other subsystem inputs controlling their output to track the same tracking signal. For each subsystem to compute the next input $u^*_i(k)$, its sensor measurement $y_i$ needs to be uncompromised. As a measurement is corrupted due to a non-zero element from the sensor attack vector, the corresponding subsystem's computed input diverges from the remaining inputs. Mathematically, to detect attacks, a difference matrix $\bm{\Psi}(k)$ is designed for every time interval $k$ of each controlled state. The structure of this matrix is,
    \begin{equation}
    \label{eq:difference_matrix}
	\bm{\Psi}(k)=\begin{bmatrix} \psi_{1,1}(k) & \psi_{1,2}(k) & \dots & \psi_{1,s}(k) \\ \psi_{2,1}(k) & \psi_{2,2}(k) &  &  \\ \vdots &  & \ddots &  \\ \psi_{s,1}(k) &  &  & \psi_{s,s}(k) \end{bmatrix}
	\end{equation}
where $\bm{\Psi}(k) \in \R^{s\times s}$ with $s$ representing the number of available measurements from the measurement vector. Each element $\psi_{i,j}\in\bm{\Psi}$ is an error computed as the absolute difference between two subsystem inputs:
    \begin{equation}
        \psi_{i,j}(k)=|u^*_i(k)-u^*_j(k)|
    \end{equation}
The $l_1$ vector norm for each row in the difference matrix \eqref{eq:difference_matrix} is computed which gives us the following vector:
    \begin{equation}
    \label{eq:difference_vector}
	\bm{\Psi^{'}}(k)=\begin{bmatrix} \lVert{\bm{\Psi}_1(k)}\rVert_1 \\ \lVert{\bm{\Psi}_2(k)}\rVert_1 \\ \vdots \\ \lVert{\bm{\Psi}_s(k)}\rVert_1 \end{bmatrix}
	\end{equation}
The minimum valued element of \eqref{eq:difference_vector} is used to form another vector $\bm{\Psi}^{'}_{min}(k) \in \R^s$, with every element equal to $\min \bm{\Psi}^{'}(k)$:
%     \begin{equation}
% 	\bm{\Psi}^{'}_{min}(k)=\begin{bmatrix} \min \bm{\Psi}^{'}(k),& \dots \text{ },&\min \bm{\Psi}^{'}(k) \end{bmatrix}^T
% 	\end{equation}
    \begin{equation}
	\bm{\Psi}^{'}_{min}(k)=\min \bm{\Psi}^{'}(k) \vec{1}_s
	\end{equation}
We now define the updated error vector as:
    \begin{align}
    \label{eq:Psi2}
	\bm{\Psi}^{''}(k)&=\bm{\Psi}^{'}(k)-\bm{\Psi}^{'}_{min}(k) \\
	& =\begin{bmatrix} \lVert{\bm{\Psi}_1(k)}\rVert_1 - \min \bm{\Psi}^{'}(k)\\ \lVert{\bm{\Psi}_2(k)}\rVert_1 - \min \bm{\Psi}^{'}(k) \\ \vdots \\ \lVert{\bm{\Psi}_s(k)}\rVert_1 - \min \bm{\Psi}^{'}(k) \end{bmatrix}
	\end{align}
	
From \eqref{eq:u_to_0} while under ideal conditions (i.e., with no noise), the error vector \eqref{eq:Psi2} has all elements equal to zero. When an $i^{th}$ sensor is under attack, the $i^{th}$ input diverges from the remaining uncompromised inputs. The $i^{th}$ element of $\bm{\Psi}^{''}(k)$ becomes non-zero due to the compromised sensor, while the rest of the elements remain zero. 

Under non-ideal conditions where noises exist, the elements of the error vector will not remain zero while sensors are uncompromised. By setting a threshold value $\delta$, all elements of the error vector need to stay below this level. By refining \eqref{eq:Psi2} for non-ideal conditions we get,
    \begin{align}
    \begin{split}
    \label{eq:Psi2_nonideal}
	\bm{\Psi^{''}}(k)&=\bm{\Psi^{'}}(k)-\bm{\Psi}^{'}_{min}(k) \\
	& =\begin{bmatrix} \lVert{\bm{\Psi}_1(k)}\rVert_1 - \min \bm{\Psi}^{'}(k)\\ \lVert{\bm{\Psi}_2(k)}\rVert_1 - \min \bm{\Psi}^{'}(k) \\ \vdots \\ \lVert{\bm{\Psi}_s(k)}\rVert_1 - \min \bm{\Psi}^{'}(k) \end{bmatrix} \leq \bm{\delta}
	\end{split}
	\end{align}
with the vector $\bm{\delta} \in \R^s$ has elements all equal to the scalar value $\delta$, which is computed from the measurement with the highest noise profile \NB{more details needed here. How is $\delta$ computed?}. After detecting and removing the compromised sensors, the updated measurement matrix reduces in size to $\bm{C} \in \R^{s' \times n}$ with $s'=s-s_a$ and the measurement set is $\bm{y}' =\bm{y}\setminus\bm{y}_a$. Once the subsystem inputs $u_i^*(k)$ have been checked by the detector, the uncompromised measurements are fused and then directed to an adaptive controller to compute an input $u(k)$ for the system \NB{block diagram needed here. Modify Fig.2 to show this}.

% DO I NEED THIS?

%Properties of the modified projection algorithm \eqref{eq:Modified_Proj_Algorithm} include:
%    \begin{enumerate}[label=(\roman*),leftmargin=3\parindent]
%	\item every iteration improves estimation:
%	    \begin{align}
%	        \|\bm{\theta}(k)-\bm{\theta}_0\|\leq\|\bm{\theta}(k-1)-\bm{\theta}_0\|, k\geq1 \nonumber
%	    \end{align}
%	\item parameter variation converges to zero:
%	    \begin{align}
%	        \lim_{k\to\infty}(\bm{\theta}(k)-\bm{\theta}(k-N))=0, \text{any finite } N>0 \nonumber
%	    \end{align}
%	\end{enumerate}
	

\subsection{Estimation Confidence}

The vehicle has multiple sensors of various noise profiles that provide state data of the system. Some of these sensors are fused to obtain a better estimation. When a compromised sensor has been removed by the detector, the system uses a smaller set of sensors for state estimation. Thus, we are interested in computing a region of confidence around the state estimate that adapts to the changing sensor set to ensure vehicle safety. We leverage the statistical technique of confidence intervals \cite{devore2011probability} to obtain a specific confidence of an estimate. Confidence intervals are used to calculate bounds which the true mean lies within of a chosen confidence percentage. Assuming the knowledge of the confidence percentage $c_p$, population standard deviation $\sigma$, the number of sensor data samples $N$, and the mean of the $N$ sensor data samples $\bar{x}$, an interval of a percentage of confidence can be calculated:
    \begin{equation}
     \label{Confidence_interval}
		C_x = \bar{x} + c_p\frac{\sigma}{\sqrt{N}}
	\end{equation}
	
% . As the number of data samples increases, the confidence interval shrinks in size to give a better estimation of the true mean \NB{you are giving the results before showing how!}	
	
For state estimation with sensor uncertainties, we need to guarantee the vehicle is within a region of confidence to prevent entering into an undesired state. Uncompromised sensor measurements from the set $\bm{y}$ are fused using filtering techniques (e.g. Kalman Filtering) and the result is a position estimate $\bm{p}=[x,y]^T$ of a certain variance $\sigma_p^2$, which depends on the known sensor variances from specifications. For our case, a multivariate confidence interval is computed to create a confidence region for state estimation. This states the vehicle is within the computed region of a specific confidence percentage.


The estimated position data has the form $\mathcal{N}(0,\sigma_p)$ where the data's population standard deviation $\sigma_p$ is known for any sensor combination. Using \eqref{Confidence_interval} we find a multivariate region the vehicle is within of a chosen confidence percentage,
    \begin{equation}
    \label{Confidence_region}
		\bm{\varepsilon}_{\bar{\bm{p}}|N} = \bar{\bm{p}} + c_p\frac{\sigma_p}{\sqrt{N}}
	\end{equation}
with $c_p$ defining the value for a specific confidence percentage, which can be found from tables in \cite{devore2011probability} and $\bar{\bm{p}}$ is the mean position estimate from the $N$ data samples. The radius of the multivariate confidence region \eqref{Confidence_region} from the center point $\bar{\bm{p}}$ is:
    \begin{equation}
    \label{Confidence_radius}
		\varepsilon = c_p\frac{\sigma_p}{\sqrt{N}}
	\end{equation}
From \eqref{Confidence_radius}, it is clear that with a larger number of $N$ data samples, the radius of the confidence region becomes smaller. Similar to the calculation of confidence intervals \eqref{Confidence_interval}, it is under the assumption that the true mean is static (i.e. is not changing over time). This cannot be assumed in the case of position estimation of a moving vehicle. 

% \begin{figure}[ht!]
% \vspace{1pt}
% \centering
% \includegraphics[width=0.48\textwidth]{Gaussian2D.png}
% \caption{Distribution of vehicle's estimated position over 100 samples in an $X-Y$ plane with equal noise variance on the $X$ and $Y$ axis. Creating a psuedo-static case allows for the calculation of a confidence region for vehicle position.}
% \label{fig:gauss_pdf}
% \end{figure}


\begin{figure}[ht!]
\begin{tabular}{cc}
\subfigure[\label{fig:1sample} ]{\includegraphics[width = 0.22\textwidth]{Figures/sample1.png}} &	
\subfigure[\label{fig:5samples} ]{\includegraphics[width = 0.22\textwidth]{Figures/sample5.png}}
\end{tabular}
\caption{A comparison of the size of the estimated confidence region as the $N$ number of data samples grow. In \ref{fig:1sample}, the estimated confidence region with 1 data sample is not as accurate. In \ref{fig:5samples}, the $N$ number of samples used is five, which gives a much smaller size and more accurate confidence region.}
\label{fig:confidence_region}
\end{figure}

To take vehicle mobility into account, we propose an adapted approach to compute the confidence region using previous estimated position measurements $\bm{p}(k-i)$, where $i=1,2,\dots,N-1$. These $N-1$ number of previous measurements need to be represented as if they were all sampled for the current position in time $k$, creating a pseudo-static set of data. As shown in Fig. \ref{fig:confidence_region}, using a static set of measurements, we are able to calculate a confidence region using more than one sample to improve estimation accuracy. The $N$ position estimate samples are described in the set:
\begin{equation}
    \bm{P}=\begin{bmatrix} \bm{p}(k) ,\bm{p}(k-1),\dots,\bm{p}(k-N+1) \end{bmatrix} 
\end{equation}
Each element of these updated sets are calculated as,
	\begin{equation}
	\bm{p}^*(k-i) = \bm{p}(k-i)+\sum_{j=i}^1 v(k-j)\theta_h(k-j)t_s 
	\end{equation}
where $i=1,2,\dots,N-1$ and the most recent position estimate at time instant $k$ is unchanged from $\hat{\bm{p}}(k)$ to $\hat{\bm{p}}^*(k)$
Translating the data coordinates into a pseudo-static form creates the updated set,
\begin{equation}
    \bm{P}^*=\begin{bmatrix} \bm{p}^*(k) ,\bm{p}^*(k-1),\dots,\bm{p}^*(k-N+1) \end{bmatrix} \nonumber
\end{equation}
. The mean of the updated set is written as $\bar{\bm{p}}^*$, which is the estimated center point used in the calculation of the confidence region. To demonstrate how this works, Fig. \ref{fig:pseudo_static} gives a visualization of position estimates translated into a pseudo-static case. Updating \eqref{Confidence_region}, we get
    \begin{equation}
    \label{Confidence_region_updated}
		\bm{\varepsilon}_{\bar{\bm{p}}^*|N} = \bar{\bm{p}}^* + c_p\frac{\sigma_p}{\sqrt{N}}
	\end{equation}
 to account for all $N-1$ translated previous data points to appear as if they all were sampled at time interval $k$.

% \begin{figure}[ht!]
% \vspace{1pt}
% \centering
% \includegraphics[width=0.48\textwidth]{pseudo_static.png}
% \caption{Translation of the original position estimates $\hat{\bm{p}}$ to a pseudo-static case $\hat{\bm{p}}^*$ as if all the position estimates were sampled from the vehicle at the current time interval $k$.}
% \label{fig:pseudo_static}
% \end{figure}


\begin{figure}[ht!]
\begin{tabular}{cc}
\subfigure[\label{fig:step_one} ]{\includegraphics[width = 0.21\textwidth]{Figures/pseudo_static_left.png}} &	
\subfigure[\label{fig:step_two} ]{\includegraphics[width = 0.21\textwidth]{Figures/pseudo_static_right.png}}
\end{tabular}
\caption{Translation of the original position estimates $\bm{p}$ to a pseudo-static case $\bm{p}^*$ as if all the position estimates were sampled from the vehicle at the current time interval $k$.}
\label{fig:pseudo_static}
\end{figure}



Creating a static case with these past position data samples introduces higher uncertainty. Uncertainties regarding the velocity sensor $\sigma_v$ and heading angle sensor $\sigma_h$ need to be accounted for. To guarantee that the true position of the vehicle is within the estimation radial bounds, the maximum error in position due to sensor noise over the furthest sample in time in $\bm{P}^*$ is calculated as:
    \begin{align}
    \begin{split}
	\varepsilon_{v,\theta_h|N}^{*}=\Big( &\big[(\bar{v}^* \cos{\bar{\theta}_h^*} - \bar{v}\cos{\bar{\theta}_h})(N-1)t_s \big]^2 \\
	&+ \big[ (\bar{v}^* \sin{\bar{\theta}_h^*} - \bar{v}\sin{\bar{\theta}_h})(N-1)t_s \big]^2 \Big) ^{1/2}
	\end{split}
	\end{align}
where,
    \begin{equation}
	\bar{v}^{*}=\bar{v}(k-i_{\varepsilon^{*}})+c_p\sigma_v \nonumber
	\end{equation}
    \begin{equation}
	\bar{v}=\bar{v}(k-i_{\varepsilon^{*}}) \nonumber
	\end{equation}
	\begin{equation}
	\bar{\theta}_h^{*}=\bar{\theta}_h(k-i_{\varepsilon^{*}})+c_p\sigma_h \nonumber
	\end{equation}
	\begin{equation}
	\bar{\theta}_h=\bar{\theta}_h(k-i_{\varepsilon^{*}}) \nonumber
	\end{equation}
with $i_{\varepsilon^{*}}=1,2,,\dots,N-1$ while average measured velocity and average measured heading angles over the past $N-1$ samples of range $i_{\varepsilon^{*}}$ are denoted by $\bar{v}$ and $\bar{\theta}_h$, respectively. Accounting for velocity and heading angle measurement error and ensure the vehicle's position is within our estimation region.


\subsection{Adaptive Motion Planning}

% Thus here we are interested to compute a confidence interval around our state estimation and adapt the vehicle's motion plan if safety constraints could be violated


With uncertainty of sensor measurements, with or without a reconfigured set of sensors, there needs to be guarantees to navigate safely. As the vehicle approaches undesired regions or follows a trajectory through a passageway that's more narrow than the confidence region at the current time interval $k$, we need to be able to reduce the size of estimate region by gathering more data samples to guarantee safety. The only two options are to sample data faster or reduce speed to gather more samples within a certain distance. Since sampling at a faster rate can't be done due to physical limitations, we need to slow the vehicle down to gather more data samples in a shorter distance to reduce estimation uncertainties.

To keep the vehicles estimated confidence region from intersecting with an undesired state, a change to the number of current and past data samples in the calculation as well as an adaptation of the velocity needs to occur. Without uncertainty of velocity and heading angle measurements, the equation to solve for the number of required $N$ samples to keep the confidence region within a specific radius is:
    \begin{equation}
    \label{conf_region1}
	    N^* = \left(c_p \frac{ \sigma_p }{ {\min \lVert \bm{x}_r - \bar{\bm{p}}^* \rVert} -\Delta(k) } \right)^2
	\end{equation}
where $ \min \lVert {\bm{x}_r-\bar{\bm{p}}^*} \rVert$ is the distance from the closest undesired region to the estimated vehicle center point position $\bar{\bm{p}}^*$.
With the assumption that there is sensor noise on the velocity and heading angle sensors, the above equation does not account for uncertainties while creating a static case. The uncertainty region $\varepsilon_{v,\theta_h|N}^{*}$ from these sensors must be accounted for. The revision to equation (\ref{conf_region1}) for a value of $N$ is:
    \begin{equation}
	    N^* = \left(c_p \frac{ \sigma_p }{ {\min \lVert \bm{x}_r - \bar{\bm{p}}^* \rVert} -\varepsilon_{v,\theta_h|N}^{*}-\Delta(k) } \right)^2
	\end{equation}
Due to the fact that $N^*$ represents the number of samples needed to reduce the estimation region to a desired size, $N^*$ needs to be an integer. We simply round $N^*$ up to the nearest integer to give us $N \in \N$.

An update of the reference velocity needs to occur when these undesired regions are within the entire confidence estimation region $ \hat{\varepsilon}_{\hat{\bar{\bm{p}}}^*|N} +\hat{\varepsilon}_{v,\theta_h|N}^{*}+\Delta(k)$ when $N=1$ to ensure the vehicle slows to capture more previous data samples with less estimation error. This reference velocity $r_v(k)$ update is calculated by:
    \begin{equation}
	    r_v(k)=r_v(k-1) \left[ \frac{ \min \lVert \bm{x}_r - \bar{\bm{p}}^* \rVert - \varepsilon_1}{\varepsilon_2 - \varepsilon_1} \right]
	\end{equation}
	\begin{equation}
	\begin{split}
	    \varepsilon_1&=\bm{\varepsilon}_{\bar{\bm{p}}^*|N} +\varepsilon_{v,\theta_h|N}^{*},\\ &\varepsilon_2=\varepsilon_1+\Delta(k) \nonumber	    
	\end{split}
	\end{equation}
	
where $\varepsilon_1$ and $\varepsilon_2$ are both radii from the estimated center position $\bar{\bm{p}}^*$.
	
%	\begin{equation}
%		\Delta(k)=[v(k)]^{\delta_v}\delta
%	\end{equation}
%where $[\delta, \delta_v] \in R^{\geq0}$ are chosen values that determine the desired distance between the closest unwanted region to the estimation region as a function of velocity.




% % INSERT ALGORITHM FOR REPLANNING VELOCITY
% \begin{algorithm}
%   \caption{Adaptive Motion for Safe Navigation} 
%   \label{alg:adapt_motion} 
%     \begin{algorithmic}[1]
% 	\State Initial conditions of system: $k=0$,$\bm{x}(0)=\bm{x}_0$
% 	\State Set $r_v(0)$ to desired velocity $r_{des}$
%     \While{$1<k\leq\infty$}
%         \State \Longunderstack[l]{ Calculate $\bar{\bm{p}}^*$ then measure closest distance\\ to undesired region $\min \lVert \bm{x}_r - \bar{\bm{p}}^* \rVert$.}
%         \State Calculate radii of intervals $\varepsilon_1$ and $\varepsilon_2$ for $N$.
%         \If{ $\min \lVert \bm{x}_r - \bar{\bm{p}}^*\rVert < \varepsilon_2(k)$}
%             \State Solve for $N$ of next iteration
%             \State Update reference for velocity $r_v(k)$
%         \Else
%             \If{$\min \lVert \bm{x}_r - \bar{\bm{p}}^*\rVert < \varepsilon_2(k)$ when $N=1$}
%                 \State Solve for $N$ of next iteration
%                 \State Update reference for velocity $r_v(k)$
%             \Else
%                 \If{$r_v(k) \neq r_{des}$}
%                     \State Reference velocity $r_v(k)=r_{des}$
%                     \State $N = 1$
%                 \Else
%                     \State Reference velocity $r_v(k) = r_v(k-1)$
%                     \State $N = 1$
%                 \EndIf
%             \EndIf
%         \EndIf
%     \EndWhile
% 	\end{algorithmic}
% \end{algorithm}



\end{section} 