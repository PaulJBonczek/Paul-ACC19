
\begin{section}{Approach}
\label{sec:approach}
In this section we describe the framework for detection of sensor attacks for systems with unknown or changing dynamics and adaptive motion planning to solve Problems \ref{problem1} and \ref{problem2} to guarantee vehicle safety. We follow the architecture in the block diagrams of Fig. \ref{fig:system_arch} to accomplish these problems. A detector monitors sensor measurements and calculated inputs for sensor attacks, which allows an uncompromised input $u(k)$ to control the system. At the same time, the position estimator along with the high level motion planner update the reference $r(k)$ to the controller to ensure safety.

\begin{figure}[ht!]
\vspace{1pt}
\centering
\includegraphics[width=0.46\textwidth]{sys_arch.png}
\caption{Overall system architecture showing the relationship between the reference model adaptive controller and the adaptive motion planner.}
\label{fig:system_arch}
\end{figure}

\subsection{Resilient Adaptive Control}
\label{sec:Res_adapt_control}

A Resilient Adaptive Controller will allow the system to detect sensor attacks while maintaining control performance as dynamical and disturbance uncertainties occur. To maintain this control performance, a Model Reference Adaptive Controller is used. First, we want to ensure adequate information of the system is known in order to design the resilient adaptive controller, the following assumptions need to be true:
	\begin{enumerate}[leftmargin=4\parindent]
	\item[$A1)$] all zeros of $B^{'}(z^{-1})z^m$ are within $|z|<1$. 
	\item[$A2)$] $n$ and $m$ are known. 
	\item[$A3)$] the system delay $d$ is known.
	\end{enumerate}
The zeros $z$ of the system are within the discrete $z-plane$ while $n$, $m$, and $d$ are the dimensions of \eqref{eq:transfer_function}. For detection of sensor attacks in dynamically changing or unknown systems, the model reference adaptive control is an effective solution to the problem. We can utilize many of the MRAC's assurances and guarantees for our technique to detect sensor attacks when the system model is changing or unknown. We know that under the assumptions of (A1-A4), the following are true \cite{tao2003adaptive}:
	\begin{enumerate}[label=(\roman*),leftmargin=4\parindent]
	\label{assumtions_ensure}
	\item[$T1)$] $y(k)$ and $u(k)$ are bounded 
	\item[$T2)$] $\lim_{k\to\infty}(y(k)-y^*(k))=0$
	\label{Truth2}
	\item[$T3)$] $\sum_{k=0}^\infty(y(k)-y^*(k))^2<\infty$
	\end{enumerate}
	
	

(WHERE I'M CURRENTLY AT WITH CORRECTIONS)


To calculate the desired input $u(k)$ to properly control the vehicle, sensor measurements need to be uncompromised. 
This means that the system's output $y(k)$ will asymptotically converge to the tracking signal $y^*(k)$ from the reference model in a finite amount of time. Properties of the modified projection algorithm \eqref{eq:Modified_Proj_Algorithm} include:
    \begin{enumerate}[label=(\roman*),leftmargin=4\parindent]
	\item every iteration improves estimation:
	    \begin{align}
	        \|\bm{\theta}(k)-\bm{\theta}_0\|\leq\|\bm{\theta}(k-1)-\bm{\theta}_0\|, k\geq1 \nonumber
	    \end{align}
	\item parameter variation converges to zero:
	    \begin{align}
	        \lim_{k\to\infty}(\bm{\theta}(k)-\bm{\theta}(k-1))=0 \nonumber
	    \end{align}
	\end{enumerate}
	\begin{align}
	   \lim_{k\to\infty}(\bm{\theta}(k)-\bm{\theta}(k-N))=0, \text{any finite } N>0 \nonumber
	\end{align}

On our vehicle, sensor redundancy is utilized for the system to be resilient against sensor attacks. Each sensor output measurement $y_i$ where $i=1,2,\dots,M$ with $M \in \N$ as the total number of sensor measurements. Each of the output sensor measurements $y_i$, when uncompromised, have convergence (T2) towards their desired tracking signal $y_i^*(k)$ at the rate determined by the reference model. 
    \begin{equation}
    \label{multiple_output_tracking}
    \lim_{k\to\infty}(y_i(k)-y^*_i(k))=0, \text{ }\forall i
    \end{equation}
This remains true with a changing reference signal $r_i(k)$, changing dynamics, or bounded disturbances. 

\begin{figure}[ht!]
\vspace{1pt}
\centering
\includegraphics[width=0.48\textwidth]{con_and_det.png}
\caption{Architecture of the detection scheme within the adaptive controlled system. Representing  the $s$ number of available measurement sensors for that output.}
\label{fig:det_arch}
\end{figure}

As shown in Fig. \ref{fig:det_arch}, every $i^{th}$ sensor will have its own MRAC subsystem, each of which are monitoring their measurements for sensor attacks. While each subsystem receives it's own individual $i^{th}$ sensor measurement $y_i$, they all share the same reference signal $r_i$, and input $u_i$ that is directly used to control the specific state of the vehicle to a desired output $y_i^*(k)$. Each MRAC subsystem calculates an updated temporary input $u^*_i$ that are fed into the detector, which analyses each $i^{th}$ input $u^*_i$ - output $y_i$ combination to check for attacked sensors. 



Since \eqref{multiple_output_tracking} should hold during any operation, it is also true the following:
\begin{equation}
    \lim_{k\to\infty}(u^*_i(k)-u^*_j(k))=0, \text{ }i\neq j
\end{equation}
where $u^*_i$ and $u^*_j$ refer to temporary inputs calculated from their respected subsystem to control the measurement signal $y_i^*(k)$ towards the desired reference output signal $y_i^*(k)$.

\NB{add Lemma}

( THRESHOLD EQUATION TO DETERMINE IF ATTACKED OR NOT RIGHT HERE)

When an attacker maliciously falsifies a sensor signal, the compromised $i^{th}$ measurement no longer follows tracking signal $y_i^*$ at the converge rate compared to the uncompromised sensor measurements of the same state. As the $i^{th}$ measurement diverges from the remaining sensor measurements of the same state, it is removed from the set of uncompromised output sensor measurements $\bm{S}$ and placed into the attacked sensor set $\bm{S}_a$.




Effective detection is constrained to when less than $\frac{N_i}{2}$ of sensors are attacked, where $N_i \in \N$ is the total number of available sensors for the $i^{th}$ output.
%\NB{IMPORTANT: this section needs to be re-organized. You should start with the concept of subsystems and show how each subsystem estimate parameters and inputs and then show mathematically how to compare and remove attacks.}

	
	
	
	
	
	
	
%Estimation of the true system characteristic model's coefficients give us this desired performance	
	
The objective of model reference adaptive control is to calculate an input signal $u(k)$ such that the system tracks $y^{*}(k)$ from the reference model given the reference input signal $r(k)$. The model reference control is designed by solving the following polynomial equation,
    \begin{equation}
	E(q^{-1})=F(q^{-1})A(q^{-1})+q^{-d}G(q^{-1})
	\end{equation}
by matching the coefficients of $q^{-i}$ for both $F(q^{-1})$ and $G(q^{-1})$ with  known polynomials $E(q^{-1})$ and $A(q^{-1})$.
To ensure stability of the reference model, we need to make an additional assumption:
    \begin{enumerate}[leftmargin=4\parindent]
	\item[$A4)$] all zeros of $E(z^{-1})z^p$ are within $|z|<1$. 
	\end{enumerate}	
Now, we express \eqref{eq:ARMA_equation_revise} as,
	\begin{equation}
	\label{eq:ARMA_equation_revise2}
	E(q^{-1})y(k+d)={\alpha}q^{-1}y(k) + {\beta}q^{-1}u(k)
	\end{equation}
with the polynomials,
	\begin{equation}
	\alpha(q^{-1})=G(q^{-1})=\alpha_0+\alpha_1q^{-1}+ \dots +\alpha_{n-1}q^{-n+1}
	\end{equation}
	\begin{align}
	\begin{split}
	\beta( q^{-1})= F(q^{-1})&B^{'}(q^{-1})=\beta_0+\beta_1q^{-1} \\
	& + \dots +\beta_{m+d-1}q^{-m-d+1}, \beta_0\neq0
	\end{split}
	\end{align}

The right side of equation \eqref{eq:ARMA_equation_revise2} can be expressed by parametrization in the form,
    \begin{equation}
	E(q^{-1})y(k+d)=\bm{\theta}_0(k)\bm{\phi}(k)
	\end{equation}
with the unknown vector $\bm{\theta}_0$ and known signal vector $\bm{\theta}_0$,
    \begin{equation}
	\bm{\theta}_0=(\alpha_0, \dots ,\alpha_{n-1},\beta_0, \dots ,\beta_{m+d-1})^T \in \R^{n+m+d}
	\end{equation}
	\begin{align}
	\begin{split}
	\bm{\phi}(k)&=(y(k), \dots ,y(k-n+1),u(k), \dots , \\
	& u(k-m-d+1))^T \in \R^{n+m+d}
	\end{split}
	\end{align}
	
Since we want the system to have the same characteristics as the reference model \eqref{eq:reference model}, we need to estimate the true parameter vector $\bm{\theta}_0$ with the estimated parameter vector $\bm{\theta}^T(k)$. 
    \begin{equation}
    \bm{\theta}(k)=(\theta_1(k), \dots ,\theta_n(k),\theta_{n+1}(k), \dots ,\theta_{n+m+d}(k))^T
	\end{equation}
We update the estimate $\bm{\theta}^T(k)$ of the true parameter vector $\bm{\theta}_0$ using a \textit{Modified Projection Algorithm}:
	\begin{equation}
	\label{eq:Modified_Proj_Algorithm}
	\bm{\theta}(k)=\bm{\theta}(k-1)+\frac{a(k)\phi(k-d)e(k)}{c+\phi^T(k-d)\phi(k-d)}
	\end{equation}
	\begin{equation}
	\bm{e}(k)=E(q^{-1})y(k)-\theta^T(k-1)\phi(k-d)
	\end{equation}
	\begin{align*}
	\varepsilon<a(k)<2-\varepsilon, 0,\varepsilon<1, c>0
	\end{align*}
	
To follow the desired tracking output $y^*(k)$ from the reference model, the adaptive control input $u(k)$ is then calculated from the equation:
    \begin{equation}
    \label{eq:tracking_model}
	\bm{\theta}^T(k)\bm{\phi}(k)=E(q^{-1})y^*(k+d)
	\end{equation}
By rearranging \eqref{eq:tracking_model} we isolate $u(k)$ to calculate our next input signal:
	\begin{align}
	u(k)=\frac{1}{\theta_{n+1}(k)}&(-\theta_1(k)y(k)-\theta_2(k)y(k-1)  \nonumber \\
    -\dots-\theta_n(k)y(k&-n-1)-\theta_{n+2}(k)u(k-1)  \\
	-\theta_{n+3}(k)u(k-2)-& \dots - \theta_{n+m+d}(k)u(k-m-d+1) \nonumber \\
	+g&H(q^{-1})r(k))^T \nonumber
	\end{align}
    \begin{equation}
	\theta_{n+1}(k)\neq0 \nonumber
	\end{equation}
	


\subsection{Estimation Confidence Region}

In this work we leverage the statistical technique of confidence intervals to obtain a specific confidence of an estimate. Confidence intervals are important because they calculate a confidence percentage that the true mean lies within the estimated bounds. As the number of data samples increases, the confidence interval shrinks in size to give a better estimation of the true mean. Assuming the knowledge of the confidence percentage $z^{*}$, population standard deviation $\sigma$, the number of sensor data samples $N$, and the mean of the $N$ sensor data samples $ \bar{x} $, a confidence interval of a chosen percentage can be calculated:
    \begin{equation}
     \label{Confidence_interval}
		C_x = \bar{x} + z^{*}\frac{\sigma}{\sqrt{N}}
	\end{equation}
	
	
For position estimation with sensor uncertainties, we need a guarantee the vehicle is within a region to prevent navigation into an undesired state. To do this, uncompromised sensor measurements are fused using filtering techniques (e.g. Kalman Filtering) and the result is a position estimate $\hat{\bm{p}}=[\hat{x},\hat{y}]^T$ of a certain variance $\sigma_p^2$, which depends on the known sensor variances from data sheet specifications. Using an $N$ number of data samples of variance $\sigma_p^2$, we are able to estimate an interval of specific confidence that the vehicle is within the these boundaries.


For our case, we want to estimate a 2-dimensional interval. By calculating this multivariate confidence interval, we name it a confidence region, we estimate a region which the vehicle is within. This method guarantees the center of the vehicle has a specific percentage of confidence that it's within this region. The data being used for estimation has the form $\mathcal{N}(0,\sigma_p)$ where the data population standard deviation $\sigma_p$ is known for any sensor combination. Using \eqref{Confidence_interval} we can find a multivariate region of a determined confidence percentage that the vehicle is within to ensure safety:
    \begin{equation}
    \label{Confidence_region}
		\hat{\bm{\varepsilon}}_{\hat{\bar{\bm{p}}}|N} = \hat{\bar{\bm{p}}} + z^{*}\frac{\sigma_p}{\sqrt{N}}
	\end{equation}
Where the radius of \eqref{Confidence_region} is,
    \begin{equation}
		\hat{\varepsilon} = z^{*}\frac{\sigma_p}{\sqrt{N}}
	\end{equation}
Similar to the calculation of confidence intervals, it is under the assumption the true mean is static, is not changing over time. This cannot be assumed in our case of position estimation of a navigating vehicle. 
\begin{figure}[ht!]
\vspace{1pt}
\centering
\includegraphics[width=0.48\textwidth]{Gaussian2D.png}
\caption{Distribution of vehicle's estimated position over 100 samples in an $X-Y$ plane with equal noise variance on the $X$ and $Y$ axis. Creating a psuedo-static case allows for the calculation of a confidence region for vehicle position.}
\label{fig:gauss_pdf}
\end{figure}

A pseudo-static form of a confidence region is made to compensate for translation of previous position measurements $\hat{\bm{p}}(k-i)$, where $i=1,2,\dots,N-1$. These $N-1$ number of previous position data points need to be represented as if they were all sampled for the current position in time $k$, creating a pseudo-static set of data to calculate the confidence region. As shown in Fig. \ref{fig:gauss_pdf}, we want to have the data samples for calculation of the confidence region look as if the vehicle is stationary. The $N$ position estimate samples are described in the set,
\begin{equation}
    \bm{P}=\begin{bmatrix} \hat{\bm{p}}(k) ,\hat{\bm{p}}(k-1),\dots,\hat{\bm{p}}(k-N+1) \end{bmatrix} 
\end{equation}
for the position coordinates in the $x$ and $y$ direction. Translating the data coordinates into a pseudo-static form will create the updated set,
\begin{equation}
    \bm{P}^*=\begin{bmatrix} \hat{\bm{p}}^*(k) ,\hat{\bm{p}}^*(k-1),\dots,\hat{\bm{p}}^*(k-N+1) \end{bmatrix} \nonumber
\end{equation}
Each element of these updated sets are calculated as,
    \begin{equation}
    \begin{split}
	\hat{p}_x^*(k-i) = \hat{p}_x(k-i)+\sum_{j=1}^i v(k-j)\cos{\theta_h(k-j)t_s} \\
	\hat{p}_y^*(k-i) = \hat{p}_y(k-i)+\sum_{j=1}^i v(k-j)\sin{\theta_h(k-j)t_s}
	\end{split}
	\end{equation}
where $i=1,2,\dots,N-1$, $\hat{p}_x^*$ and $\hat{p}_y^*$ are the $x$ and $y$ position coordinates within $\hat{\bm{p}}^*$ and the most recent position estimate at the time instant $k$ is unchanged from $\hat{\bm{p}}(k)$ to $\hat{\bm{p}}^*(k)$. The mean of the updated set is written as $\hat{\bar{\bm{p}}}^*$, which is used for the calculation of the estimated confidence interval region. To demonstrate how this works, Fig. \ref{fig:pseudo_static} gives a visualization of how the position estimates are transitioned into a pseudo-static case.

\begin{figure}[ht!]
\vspace{1pt}
\centering
\includegraphics[width=0.48\textwidth]{pseudo_static.png}
\caption{Translation of the original position estimates $\hat{\bm{p}}(k)$ to a pseudo-static case $\hat{\bm{p}}^*(k)$ as if all the position estimates were sampled from the vehicle at the current time $k$.}
\label{fig:pseudo_static}
\end{figure}

Creating a pseudo-static case with these past position data samples introduces higher uncertainty. Uncertainties regarding the velocity sensor $\sigma_v$ and heading angle sensor $\sigma_h$ need to be accounted for. To guarantee the true position of the vehicle is within the estimation radial bounds, the maximum error in position due to the actuator and sensor noises over the furthest sample in time in $\bm{P}$ is calculated as:
    \begin{equation}
	\hat{\varepsilon}_{v,\theta_h|N}^{\star}=\sqrt{(v^{\star}\cos{\theta_h^{\star}})^2+(v^{\star}\sin{\theta_h^{\star}})^2}
	\end{equation}
where,
    \begin{equation}
	v^{\star}=\bar{v}(k-i_{\varepsilon^{\star}})+z^{*}\sigma_v \nonumber
	\end{equation}
	\begin{equation}
	\theta_h^{\star}=\bar{\theta}_h(k-i_{\varepsilon^{\star}})+z^{*}\sigma_h \nonumber
	\end{equation}
with $i_{\varepsilon^{\star}}=[1,2,,\dots,N]$ while average measured velocity and average measured heading angles over the past $N$ samples are denoted by $\bar{v}$ and $\bar{\theta}_h$, respectively. Doing this account for velocity and heading angle measurement error and ensure the vehicle's position is within our estimation region.


\subsection{Adaptive Motion Planning}
With uncertainty of sensor measurements, with or without the loss of a compromised sensors, there needs to be guarantees to safely navigate a vehicle without accidents. As the vehicle approaches obstacles or unwanted regions with position uncertainty, changes to the vehicle's motion need to be made. To keep the vehicles estimated confidence region from intersecting with an unwanted region, a change to the number of current and past data samples in the calculation as well as an adaptation of the velocity. Without uncertainty of velocity and heading angle measurements, the equation to solve for the number of required $N$ samples to keep the confidence region within a specific radius is:
    \begin{equation}
    \label{conf_region1}
	    N^* = \left(z^{*} \frac{ \sigma_p }{ {\lVert \bm{x}_{r_{\hat{\bar{\bm{p}}}}} - \hat{\bar{\bm{p}}}^* \rVert} -\Delta(k) } \right)^2
	\end{equation}
where $\lVert {\bm{x}_{r_{\hat{\bar{\bm{p}}}}}-\hat{\bar{\bm{p}}}^*} \rVert$ is the distance from the closest undesired region to the estimated vehicle center point position $\hat{\bar{\bm{p}}}^*$.
With the assumption of Normally distributed sensor noise on the velocity and heading angle sensors, the above equation is not suitable. The uncertainty region $\hat{\varepsilon}_{v,\theta_h|N}^{\star}$ from these sensors must be accounted for. The revision to equation (\ref{conf_region1}) for a sufficient value of $N$ is:
    \begin{equation}
	    N^* = \left(z^{*} \frac{ \sigma_p }{ {\lVert \bm{x}_{r_{\hat{\bar{\bm{p}}}}} - \hat{\bar{\bm{p}}}^* \rVert} -\hat{\varepsilon}_{v,\theta_h|N}^{\star}-\Delta(k) } \right)^2
	\end{equation}
Due to the fact that $N^*$ represents the number of samples needed to reduce the estimation region to a desired size, $N^*$ needs to be an integer. We simply round $N^*$ up to the nearest integer to give us $N \in \N$.

An update of the reference velocity needs to occur when these undesired regions are within the entire confidence estimation region $ \hat{\varepsilon}_{\hat{\bar{\bm{p}}}^*|N} +\hat{\varepsilon}_{v,\theta_h|N}^{\star}+\Delta(k)$ when $N=1$ to ensure the vehicle slows to capture more previous data samples with less estimation error. This reference velocity $r_v(k)$ update is calculated by:
    \begin{equation}
	    r_v(k)=r_v(k-1) \left[ \frac{\lVert \bm{x}_{r_{\hat{\bar{\bm{p}}}}} - \hat{\bar{\bm{p}}}^* \rVert - \hat{\varepsilon}_1}{\hat{\varepsilon}_2 - \hat{\varepsilon}_1} \right]
	\end{equation}
	\begin{equation}
	\begin{split}
	    \hat{\varepsilon}_1&=\hat{\bm{\varepsilon}}_{\hat{\bar{\bm{p}}}^*|N} +\hat{\varepsilon}_{v,\theta_h|N}^{\star},\\ &\hat{\varepsilon}_2=\hat{\varepsilon}_1+\Delta(k) \nonumber	    
	\end{split}
	\end{equation}
	
where $\hat{\varepsilon}_1$ and $\hat{\varepsilon}_2$ are both radii from the estimated center position $\hat{\bar{\bm{p}}}^*$.
	
%	\begin{equation}
%		\Delta(k)=[v(k)]^{\delta_v}\delta
%	\end{equation}
%where $[\delta, \delta_v] \in R^{\geq0}$ are chosen values that determine the desired distance between the closest unwanted region to the estimation region as a function of velocity.


% INSERT ALGORITHM FOR REPLANNING VELOCITY
\begin{algorithm}
   \caption{Adaptive Motion for Safe Navigation} 
   \label{alg:adapt_motion} 
    \begin{algorithmic}[1]
	\State Initial conditions of system: $k=0$,$\bm{x}(0)=\bm{x}_0$
	\State Set $r_v(0)$ to desired velocity $r_{v_{des}}(k)$
    \While{$1<k\leq\infty$}
        \State \Longunderstack[l]{ Calculate $\hat{\bar{\bm{p}}}$ then measure closest distance\\ to undesired region $\|\bm{x}_{r_{\hat{\bar{\bm{p}}}}} - \hat{\bar{\bm{p}}}\|$.}
        \State Calculate radii of intervals $\hat{\varepsilon}_1$ and $\hat{\varepsilon}_2$ for $N$.
        \If{ $\|\bm{x}_{r_{\hat{\bar{\bm{p}}}}} - \hat{\bar{\bm{p}}}\| < \hat{\varepsilon}_2(k)$}
            \State Solve for suitable $N$ of next iteration
            \State Update reference for velocity $r_v(k)$
        \Else
            \If{$\|\bm{x}_{r_{\hat{\bar{\bm{p}}}}} - \hat{\bar{\bm{p}}}\| < \varepsilon_2(k)$ when $N=1$}
                \State Solve for a suitable $N$
                \State Update reference for velocity $r_v(k)$
            \Else
                \If{$r_v(k) \neq r_{v_{des}}$}
                    \State Reference velocity $r_v(k)=r_{v_{des}}$
                    \State $N = 1$
                \Else
                    \State Reference velocity $r_v(k) = r_v(k-1)$
                    \State $N = 1$
                \EndIf
            \EndIf
        \EndIf
    \EndWhile
	\end{algorithmic}
\end{algorithm}



\end{section} 